<!--
 Copyright 2024 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/thomas-lowry/figma-plugin-ds/dist/figma-plugin-ds.css" />
    <link rel="stylesheet" href="style.css" />
    <script src="https://unpkg.com/canvaskit-wasm/bin/canvaskit.js"></script>
</head>

<!-- BEGIN OF SHADER PLUGIN UI -->
<div class="page-padding-large">
    <div style="align-items: flex-start; gap: 16px; display: flex;">
        <div class="container" style="border: 1px black solid; max-width: 256px; max-height: 256px; overflow: hidden;">
            <canvas id="shaderPreview" width="256px" height="256px" />
        </div>
        <div style="width: auto; flex-grow: 1; max-height: 256px; overflow-y: scroll;">
            <div style="border: 2px black solid;">
                <div>
                    <div style="height: 32px;" class="center-vertically-container">uniform float3 iResolution;</div>
                    <div style="border-top: 1px black solid; height: 32px;" class="center-vertically-container">uniform
                        float iTime;</div>
                </div>
                <div id="uniforms"></div>
            </div>
            <div style="margin-top: 8px;" class="hug-width-container">
                <span class="icon-button" onclick="createUniform()">
                    <span class="icon icon--plus"></span>
                </span>
                <span>Uniform</span>
            </div>
        </div>
    </div>
    <div style="display:flex; flex-wrap: wrap; overflow-y: auto; gap: 4px; margin-top: 8px;">
        <button class="button--primary" onclick="loadShaderCode('julia')">Julia</button>
        <button class="button--primary" onclick="loadShaderCode('cloudy_sky')">CloudySky</button>
        <button class="button--primary" onclick="loadShaderCode('discrete_ocean')">DiscreteOcean</button>
        <button class="button--primary" onclick="loadShaderCode('fibonacci_sphere')">FibonacciSphere</button>
        <button class="button--primary" onclick="loadShaderCode('gradient')">Gradient</button>
        <button class="button--primary" onclick="loadShaderCode('star')">Star</button>
        <button class="button--primary" onclick="clearShaderCode()">CUSTOM</button>
    </div>

    <div style="margin-top: 8px; display: flex;">
        <textarea id="shaderCodeInput" name="shaderCodeInput" style="width: 100%;" rows="12"
            placeholder="Enter your shader code"></textarea>
        <button id="previewShaderButton" class="button--primary" onclick="runShader()">Preview</button>
    </div>

    <div id="nodeSection" class="collapsible" style="margin-top: 8px;">
        <div id="cleared">No nodes selected. Select a node that can have a background to start.</div>
        <div id="selected" style="display: flex; gap:4px; align-items: center">
            <div id="nodeId" style="width: 100%;"></div>
            <button id="loadShaderButton" class="button--primary">Load Shader</button>
        </div>
    </div>
    <div id="nodeActions" class="content">
        <div style="display: flex; align-items: center; gap:4px;">
            <div style="width: 100%;">
                <input id="useShaderFallbackColor" type="checkbox" checked="true"></input>
                <span class="tooltip">
                    <img src="images/dials/info-blue.svg">
                    <span class="tooltiptext left-20">When unchecked, DesignCompose will draw the background image from
                        the figma node.</span>
                </span>
                Use the solid color <span style="background-color: #FF46A2;">#FF46A2</span> as background when shader is
                not supported on lower sdks.
            </div>
            <button id="setShaderButton" class="button--primary tooltip">Apply Shader
                <span class="tooltiptext left-80">Use the runtime shader to render the background. It only works on
                    Android 13+.</span></button>
        </div>
        <hr />
        <div style="margin-top: 4px; display: flex; gap:4px; align-items: center;">
            <div style="width: 100%;">
                When clear shader, shader preview image will be removed. If a text has no background after shader
                preview image gets removed, we will set the text color to the solid color <span
                    style="background-color: #FF46A2;">#FF46A2</span>.
            </div>
            <button id="clearShaderButton" class="button--primary" onclick="clearShaderFromFigmaNode()">Clear
                Shader</button>
        </div>
    </div>

    <hr />
    <div>
        Shader examples are from:
        <li><a target="_blank" href="https://shaders.skia.org/">https://shaders.skia.org/</a></li>
        <li><a target="_blank" href="https://godotshaders.com/">https://godotshaders.com/</a></li>
    </div>

    <div style="margin-top: 4px">
        This tool is developed using Skia CanvasKit, please use
        <a target="_blank" href="https://shaders.skia.org/">https://shaders.skia.org/</a> to debug.
    </div>

    <dialog id="createUniformDialog">
        <div><b>Choose which uniform to create</b></div>
        <p>
            <label><input type="radio" name="uniformType" value="float" checked="true">Float</label>
            <br>
            <label><input type="radio" name="uniformType" value="floatArray">Float Array</label>
            <br>
            <label><input type="radio" name="uniformType" value="color">Color</label>
            <br>
            <label><input type="radio" name="uniformType" value="int">Int</label>
        </p>
        <div style="display: flex; gap: 4px;">
            <button id="continueButton" class="button--primary" style="flex-grow: 1;"
                onclick="continueUniformCreation()">Continue</button>
        </div>
    </dialog>

    <dialog id="createFloatUniformDialog">
        <div><b>Create float uniform</b></div>
        <p>
        <div style="display: flex; gap: 8px;">
            <label for="floatUniformName" style="flex-grow: 1;">Name:</label>
            <input type="text" id="floatUniformName" placeholder="iFloat" autofocus></input>
        </div>
        <div style="display: flex;gap: 8px;">
            <label for="floatUniformMin" style="flex-grow: 1;">Min:</label>
            <input type="number" id="floatUniformMin" placeholder="0" step="0.1"></input>
        </div>
        <div style="display: flex;gap: 8px;">
            <label for="floatUniformMax" style="flex-grow: 1;">Max:</label>
            <input type="number" id="floatUniformMax" placeholder="1" step="0.1"></input>
        </div>
        </p>
        <div style="display: flex; gap: 4px;">
            <button id="createFloatUniformButton" class="button--primary" style="flex-grow: 1;">Create</button>
            <button id="closeFloatUniformButton" class="button--primary" style="flex-grow: 1;">Close</button>
        </div>
    </dialog>

    <dialog id="createColorUniformDialog">
        <div><b>Create color uniform</b></div>
        <p>
        <div style="display: flex; gap: 8px;">
            <label for="colorUniformName" style="flex-grow: 1;">Name:</label>
            <input type="text" id="colorUniformName" placeholder="iColor" autofocus></input>
        </div>
        <input type="checkbox" id="colorUniformAlphaOption">Create alpha slider</input>
        </p>
        <div style="display: flex; gap: 4px;">
            <button id="createColorUniformButton" class="button--primary" style="flex-grow: 1;">Create</button>
            <button id="closeColorUniformButton" class="button--primary" style="flex-grow: 1;">Close</button>
        </div>
    </dialog>

    <dialog id="createFloatArrayUniformDialog">
        <div><b>Create float array uniform</b></div>
        <p>
        <div style="display: flex; gap: 8px;">
            <label for="floatArrayUniformName" style="flex-grow: 1;">Name:</label>
            <input type="text" id="floatArrayUniformName" placeholder="iFloats" autofocus></input>
        </div>
        <label><input type="radio" name="floatArrayUniformType" value="float2" checked="true">float2</label>
        <br>
        <label><input type="radio" name="floatArrayUniformType" value="float3">float3</label>
        <br>
        <label><input type="radio" name="floatArrayUniformType" value="float4">float4</label>
        </p>
        <div style="display: flex; gap: 4px;">
            <button id="createFloatArrayUniformButton" class="button--primary" style="flex-grow: 1;">Create</button>
            <button id="closeFloatArrayUniformButton" class="button--primary" style="flex-grow: 1;">Close</button>
        </div>
    </dialog>

    <dialog id="createIntUniformDialog">
        <div><b>Create int uniform</b></div>
        <p>
        <div style="display: flex; gap: 8px;">
            <label for="intUniformName" style="flex-grow: 1;">Name:</label>
            <input type="text" id="intUniformName" placeholder="iCase" autofocus></input>
        </div>
        </p>
        <div style="display: flex; gap: 4px;">
            <button id="createIntUniformButton" class="button--primary" style="flex-grow: 1;">Create</button>
            <button id="closeIntUniformButton" class="button--primary" style="flex-grow: 1;">Close</button>
        </div>
    </dialog>

</div>
<!-- END OF SHADER PLUGIN UI -->

<script>
    let presetUniforms = ["iResolution", "iMouse", "iTime"];
    let shaderUniformTypeMap = {
        "color3": "float3",
        "color4": "float4",
    };
    function getUniformDeclarationType(uniformType) {
        let declarationType = shaderUniformTypeMap[uniformType];
        return declarationType ? declarationType : uniformType;
    }

    let canvas = document.getElementById("shaderPreview");
    let shaderWidth = 256;
    let shaderHeight = 256;
    let shaderCodeInput = document.getElementById("shaderCodeInput");

    let nodeSection = document.getElementById("nodeSection");
    let nodeCleared = document.getElementById("cleared");
    let nodeSelected = document.getElementById("selected");
    let loadShaderButton = document.getElementById("loadShaderButton");
    let nodeActions = document.getElementById("nodeActions");
    let setShaderButton = document.getElementById("setShaderButton");
    let useShaderFallbackColor = document.getElementById("useShaderFallbackColor");
    let clearShaderButton = document.getElementById("clearShaderButton");

    let currentShader = null;

    let currentImageSnapshot = null;

    const customUniforms = [];
    const uniformTypeMap = new Map();
    const uniforms = document.getElementById("uniforms");

    const createUniformDialog = document.getElementById("createUniformDialog");
    const createFloatUniformDialog = document.getElementById("createFloatUniformDialog");
    const createFloatArrayUniformDialog = document.getElementById("createFloatArrayUniformDialog");
    const createColorUniformDialog = document.getElementById("createColorUniformDialog");
    const createIntUniformDialog = document.getElementById("createIntUniformDialog");

    function createUniform() {
        createUniformDialog.showModal();
    }

    function continueUniformCreation() {
        let selectedUniformType = document.querySelector('input[name="uniformType"]:checked');
        if (selectedUniformType) {
            switch (selectedUniformType.value) {
                case "float":
                    createFloatUniformDialog.showModal();
                    break;
                case "floatArray":
                    createFloatArrayUniformDialog.showModal();
                    break;
                case "color":
                    createColorUniformDialog.showModal();
                    break;
                case "int":
                    createIntUniformDialog.showModal();
                    break;
            }
            createUniformDialog.close();
        } else {
            alert("No uniform type selected!");
        }
    }

    const createFloatUniformButton = document.getElementById("createFloatUniformButton");
    const closeFloatUniformButton = document.getElementById("closeFloatUniformButton");
    const floatUniformNameInput = document.getElementById("floatUniformName");
    const floatUniformMin = document.getElementById("floatUniformMin");
    const floatUniformMax = document.getElementById("floatUniformMax");

    // "Create" button closes the dialog and creates the uniform
    createFloatUniformButton.onclick = async () => {
        const uniformName = floatUniformNameInput.value;
        createShaderFloatUniform(floatUniformNameInput.value, null, floatUniformMin.value, floatUniformMax.value);
        await runShader();
    };

    function createShaderFloatUniform(uniformName, floatValue, uniformMin, uniformMax) {
        let newUniformEntry = createShaderUniform(uniformName, "float");
        if (!newUniformEntry) {
            return;
        }
        // Uniform is created successfully. Close the creation dialog.
        createFloatUniformDialog.close();

        const sliderLine = document.createElement("div");
        sliderLine.classList.add("center-vertically-container");
        const uniformSlider = document.createElement("input");
        uniformSlider.id = `slider_${uniformName}`;
        uniformSlider.classList.add("slider");
        uniformSlider.type = "range";
        const minValue = uniformMin ? Number(uniformMin) : 0;
        uniformSlider.min = minValue;
        const maxValue = Math.max(uniformMax ? Number(uniformMax) : 1, minValue + 1);
        uniformSlider.max = maxValue;
        uniformSlider.step = "0.001";
        uniformSlider.value = floatValue ? floatValue : (minValue + maxValue) / 2;
        sliderLine.appendChild(uniformSlider);

        const uniformValue = document.createElement("span");
        uniformValue.innerHTML = uniformSlider.value;
        uniformSlider.oninput = function () {
            uniformValue.innerHTML = this.value;
        }
        sliderLine.appendChild(uniformValue);
        newUniformEntry.appendChild(sliderLine);
        uniforms.appendChild(newUniformEntry);
    }

    closeFloatUniformButton.onclick = () => {
        createFloatUniformDialog.close();
    };

    const createFloatArrayUniformButton = document.getElementById("createFloatArrayUniformButton");
    const closeFloatArrayUniformButton = document.getElementById("closeFloatArrayUniformButton");
    const floatArrayUniformNameInput = document.getElementById("floatArrayUniformName");

    // "Create" button closes the dialog and creates the uniform
    createFloatArrayUniformButton.onclick = async () => {
        const uniformName = floatArrayUniformNameInput.value;
        let selectedUniformType = document.querySelector('input[name="floatArrayUniformType"]:checked');
        createShaderFloatArrayUniform(floatArrayUniformNameInput.value, selectedUniformType.value, null);
        await runShader();
    };

    function createShaderFloatArrayUniform(uniformName, uniformType, uniformValue) {
        let newUniformEntry = createShaderUniform(uniformName, uniformType);
        if (!newUniformEntry) {
            return;
        }

        // Uniform is created successfully. Close the creation dialog.
        createFloatArrayUniformDialog.close();

        // Create inputs fields
        const inputsLine = document.createElement("div");
        let sizeMap = { "float2": 2, "float3": 3, "float4": 4 };
        let arraySize = sizeMap[uniformType];
        for (let i = 0; i < arraySize; i++) {
            let input = document.createElement("input");
            input.type = "number";
            input.value = uniformValue ? uniformValue[i] : 0;
            input.id = `input_${uniformName}_${i}`;
            inputsLine.appendChild(input);
        }
        newUniformEntry.appendChild(inputsLine);
        uniforms.appendChild(newUniformEntry);
    }

    closeFloatArrayUniformButton.onclick = () => {
        createFloatArrayUniformDialog.close();
    };

    const createColorUniformButton = document.getElementById("createColorUniformButton");
    const closeColorUniformButton = document.getElementById("closeColorUniformButton");
    const colorUniformNameInput = document.getElementById("colorUniformName");
    const colorUniformAlphaOption = document.getElementById("colorUniformAlphaOption");

    // "Create" button closes the dialog and creates the uniform
    createColorUniformButton.onclick = async () => {
        const uniformName = colorUniformNameInput.value;
        const uniformType = colorUniformAlphaOption.checked ? "color4" : "color3";
        createShaderColorUniform(uniformName, uniformType, null);
        await runShader();
    };

    function createShaderColorUniform(uniformName, uniformType, colorValue) {
        let newUniformEntry = createShaderUniform(uniformName, uniformType);
        if (!newUniformEntry) {
            return;
        }

        // Uniform is created successfully. Close the creation dialog.
        createColorUniformDialog.close();

        const deleteButton = newUniformEntry.querySelector('span.icon-button');
        const colorInput = document.createElement("input");
        colorInput.type = "color";
        colorInput.id = `color_${uniformName}`;
        deleteButton.insertAdjacentElement('beforebegin', colorInput);
        if (colorValue) {
            colorInput.value = rgbFloatToHex(colorValue);
        }

        if (uniformType == "color4") {
            const sliderLine = document.createElement("div");
            sliderLine.classList.add("center-vertically-container");
            const uniformSlider = document.createElement("input");
            uniformSlider.id = `alpha_${uniformName}`;
            uniformSlider.classList.add("slider");
            uniformSlider.type = "range";
            uniformSlider.min = 0;
            uniformSlider.max = 1;
            uniformSlider.step = "0.001";
            uniformSlider.value = colorValue ? colorValue.a : 1.0;
            sliderLine.appendChild(uniformSlider);

            const uniformValue = document.createElement("span");
            uniformValue.innerHTML = uniformSlider.value;
            uniformSlider.oninput = function () {
                uniformValue.innerHTML = this.value;
            }
            sliderLine.appendChild(uniformValue);
            newUniformEntry.appendChild(sliderLine);
        }
        uniforms.appendChild(newUniformEntry);
    }

    closeColorUniformButton.onclick = () => {
        createColorUniformDialog.close();
    };

    const createIntUniformButton = document.getElementById("createIntUniformButton");
    const closeIntUniformButton = document.getElementById("closeIntUniformButton");
    const intUniformNameInput = document.getElementById("intUniformName");

    // "Create" button closes the dialog and creates the uniform
    createIntUniformButton.onclick = async () => {
        const uniformName = intUniformNameInput.value;
        createShaderIntUniform(intUniformNameInput.value, null);
        await runShader();
    };

    function createShaderIntUniform(uniformName, intValue) {
        let newUniformEntry = createShaderUniform(uniformName, "int");
        if (!newUniformEntry) {
            return;
        }

        // Uniform is created successfully. Close the creation dialog.
        createIntUniformDialog.close();

        // Create inputs fields
        const inputsLine = document.createElement("div");
        let input = document.createElement("input");
        input.id = `input_${uniformName}`;
        input.type = "number";
        input.value = intValue ? intValue : 0;
        inputsLine.appendChild(input);
        newUniformEntry.appendChild(inputsLine);

        uniforms.appendChild(newUniformEntry);
    }

    closeIntUniformButton.onclick = () => {
        createIntUniformDialog.close();
    };

    function createShaderUniform(uniformName, uniformType) {
        if (presetUniforms.includes(uniformName) || customUniforms.includes(uniformName)) {
            alert("This uniform already exists, please use a different name.");
            return null;
        }
        const regex = /^[a-zA-Z_].*$/;
        if (uniformName.length == 0 || !uniformName.match(regex)) {
            alert("Invalid uniform name, please use a different name");
            return null;
        }
        customUniforms.push(uniformName);
        uniformTypeMap.set(uniformName, uniformType);

        const newUniformEntry = document.createElement("div");
        newUniformEntry.style.borderTop = "1px solid black";

        const shaderLine = document.createElement("div");
        shaderLine.classList.add("center-vertically-container");
        const shaderCode = document.createElement("span");
        const declarationType = getUniformDeclarationType(uniformType);
        shaderCode.textContent = `uniform ${declarationType} ${uniformName};`;
        shaderLine.appendChild(shaderCode);

        const deleteButton = createDeleteButton(uniformName, newUniformEntry);
        shaderLine.appendChild(deleteButton);
        newUniformEntry.appendChild(shaderLine);
        return newUniformEntry;
    }

    function createDeleteButton(uniformName, uniformEntry) {
        // Update the selector in creating color uniform flow if changes the delete button type.
        const deleteButton = document.createElement("span");
        deleteButton.classList.add("icon-button");
        const deleteIcon = document.createElement("span");
        deleteIcon.classList.add("icon");
        deleteIcon.classList.add("icon--close");
        deleteButton.appendChild(deleteIcon);
        deleteButton.onclick = async e => {
            const index = customUniforms.indexOf(uniformName);
            customUniforms.splice(index, 1);
            uniformTypeMap.delete(uniformName);
            uniforms.removeChild(uniformEntry);

            await runShader();
        };
        return deleteButton;
    }

    function hexToRgbFloat(hex) {
        // Remove the '#' if present
        hex = hex.replace('#', '');

        // Parse hex values
        const r = parseInt(hex.substring(0, 2), 16) / 255;
        const g = parseInt(hex.substring(2, 4), 16) / 255;
        const b = parseInt(hex.substring(4, 6), 16) / 255;

        return { r, g, b };
    }

    function rgbFloatToHex(rgbColor) {
        function componentToHex(c) {
            const hex = Math.round(c * 255).toString(16);
            return hex.padStart(2, '0');
        }
        return "#" + componentToHex(rgbColor.r) + componentToHex(rgbColor.g) + componentToHex(rgbColor.b);
    }

    function clearUniforms() {
        customUniforms.length = 0;
        uniformTypeMap.clear();
        uniforms.innerHTML = "";
    }

    function previewUniformValue(uniform) {
        const type = uniformTypeMap.get(uniform);
        const floatArray = [];
        switch (type) {
            case "float":
                const slider = document.getElementById(`slider_${uniform}`);
                return parseFloat(slider.value);
            case "float2":
            case "float3":
            case "float4":
                for (let i = 0; i < 4; i++) {
                    const input = document.getElementById(`input_${uniform}_${i}`);
                    if (input) {
                        floatArray.push(parseFloat(input.value));
                    }
                }
                return floatArray;
                break;
            case "color3":
            case "color4":
                const color3 = document.getElementById(`color_${uniform}`);
                let rgb3 = hexToRgbFloat(color3.value);
                floatArray.push(rgb3.r);
                floatArray.push(rgb3.g);
                floatArray.push(rgb3.b);
                const alpha = document.getElementById(`alpha_${uniform}`);
                if (alpha) {
                    floatArray.push(parseFloat(alpha.value));
                }
                return floatArray;
            case "int":
                const input = document.getElementById(`input_${uniform}`);
                return parseInt(input.value);
        }
    }

    function uniformValue(uniform) {
        const type = uniformTypeMap.get(uniform);
        switch (type) {
            case "float":
            case "float2":
            case "float3":
            case "float4":
            case "int":
                return previewUniformValue(uniform);
            case "color3":
            case "color4":
                const color3 = document.getElementById(`color_${uniform}`);
                let rgb3 = hexToRgbFloat(color3.value);
                const alpha = document.getElementById(`alpha_${uniform}`);
                return {
                    r: rgb3.r,
                    g: rgb3.g,
                    b: rgb3.b,
                    a: alpha ? parseFloat(alpha.value) : 1.0
                };
        }
    }

    function uniformExtras(uniform) {
        const type = uniformTypeMap.get(uniform);
        if (type == "float") {
            const slider = document.getElementById(`slider_${uniform}`);
            return {
                min: parseFloat(slider.min),
                max: parseFloat(slider.max)
            };
        }
        return null;
    }

    function clearShaderFromFigmaNode() {
        parent.postMessage({
            pluginMessage: {
                msg: 'clearShader',
            }
        }, '*');
    }

    async function clearShaderCode() {
        clearUniforms();
        shaderCodeInput.value = `
vec4 main(float2 fragCoord) {
    return vec4(0, 0, 0, 1);
}`;
        currentShader = null;
        await runShader();
    }

    function loadShaderCode(shader) {
        clearUniforms();
        parent.postMessage({
            pluginMessage: {
                msg: 'loadShaderCode',
                shader: shader,
            }
        }, '*');
    }

    async function runShader() {
        CanvasKitInit({
            locateFile: (file) =>
                "https://unpkg.com/canvaskit-wasm@latest/bin/" + file,
        }).then((CanvasKit) => {

            const paint = new CanvasKit.Paint();
            const startTimeMs = Date.now();
            let mouseClickX = 0;
            let mouseClickY = 0;
            let mouseDragX = 0;
            let mouseDragY = 0;
            let lastMousePressure = 0;

            let extraUniforms = "////// User supplied inputs ////// \n";
            customUniforms.forEach(function (uniform) {
                const type = uniformTypeMap.get(uniform);
                if (type == "color3" || type == "color4") {
                    extraUniforms += `uniform ${type.replace("color", "float")} ${uniform};\n`;
                } else {
                    extraUniforms += `uniform ${type} ${uniform};\n`;
                }
            });
            extraUniforms += "////// End of user supplied inputs ////// \n";

            const prog = `
// Inputs supplied by shaders.skia.org:
uniform float3 iResolution;      // Viewport resolution (pixels)
uniform float  iTime;            // Shader playback time (s)
uniform float4 iMouse;           // Mouse drag pos=.xy Click pos=.zw (pixels)
` + extraUniforms + shaderCodeInput.value;

            const effect = CanvasKit.RuntimeEffect.Make(prog);
            if (!effect) {
                throw "Can not compile..."
            }

            // Create new surface only when the shader code compiles fine.
            let surface = CanvasKit.MakeCanvasSurface(canvas.id);
            if (!surface) {
                throw "Could not make surface";
            }
            const skcanvas = surface.getCanvas();

            function drawFrame(canvas) {
                const iTime = (Date.now() - startTimeMs) / 1000;
                const uniforms = [
                    shaderWidth, shaderHeight, 1, // vec3 iResolution(x, y, z);
                    iTime, // iTime
                    mouseDragX, mouseDragY, mouseClickX, mouseClickY, // iMouse(x, y, z, w)
                ];
                customUniforms.forEach(function (uniform) {
                    const value = previewUniformValue(uniform);
                    if (typeof value === "string" || typeof value === "number") {
                        uniforms.push(value);
                    } else {
                        uniforms.push(...value);
                    }
                });

                const shader = effect.makeShader(uniforms);
                if (!shader) {
                    throw "Could not make shader";
                }
                paint.setShader(shader);
                skcanvas.drawPaint(paint);
                shader.delete();

                currentShader = prog;

                // Have to make image snapshot in draw frame to capture an image successfully.
                // Simply calling make image snapshot when clicking on the set shader button only
                // captures an empty image.
                if (currentImageSnapshot != null) {
                    currentImageSnapshot.delete();
                }
                currentImageSnapshot = surface.makeImageSnapshot();

                surface.requestAnimationFrame(drawFrame);
            }
            surface.requestAnimationFrame(drawFrame);

            canvas.addEventListener("pointermove", (e) => {
                if (e.pressure && !lastMousePressure) {
                    mouseClickX = e.offsetX;
                    mouseClickY = e.offsetY;
                }
                lastMousePressure = e.pressure;
                if (!e.pressure) {
                    return;
                }
                mouseDragX = e.offsetX;
                mouseDragY = e.offsetY;
            });

            setShaderButton.onclick = e => {
                if (currentShader != null) {
                    const shaderUniforms = [];
                    customUniforms.forEach(function (uniform) {
                        let shaderUniform = {
                            uniformName: uniform,
                            uniformType: uniformTypeMap.get(uniform),
                            uniformValue: uniformValue(uniform),
                            extras: uniformExtras(uniform),
                        };
                        shaderUniforms.push(shaderUniform);
                    });

                    const color = useShaderFallbackColor.checked ? "#FF46A2" : undefined;
                    parent.postMessage({
                        pluginMessage: {
                            msg: 'setShader',
                            shader: currentShader,
                            shaderFallbackColor: color,
                            shaderUniforms: shaderUniforms,
                        }
                    }, '*');
                } else {
                    console.error("There is no shader running....");
                }

                const skImage = surface.makeImageSnapshot();
                if (skImage != null) {
                    parent.postMessage({
                        pluginMessage: {
                            msg: 'insertImage',
                            imageBytes: skImage.encodeToBytes(),
                        }
                    }, '*');
                    skImage.delete();
                } else {
                    console.error("There is no image captured...");
                }

            };
        }); ////// END OF CANVAS KIT //////
    }

    loadShaderCode('julia');

    function showModal() {
        var modal = document.getElementById("shaderInfo");
        modal.style.display = "block";
    }

    window.onmessage = async function (event) {
        let msg = event.data.pluginMessage;
        if (msg.msg == 'shaderCode') {
            clearUniforms();
            shaderCodeInput.value = msg.code;
            await runShader();
            return;
        }

        if (msg.msg == 'shader-selection-cleared') {
            nodeSection.classList.remove("active");
            nodeCleared.style.display = "block";
            nodeSelected.style.display = "none";
            nodeActions.style.display = "none";
            shaderWidth = 256;
            shaderHeight = 256;
            canvas.width = shaderWidth;
            canvas.height = shaderHeight;
            await runShader();
            return;
        }
        if (msg.msg == "shader-selection") {
            nodeCleared.style.display = "none";
            nodeSelected.style.display = "flex";
            nodeSection.classList.add("active");
            nodeActions.style.display = "block";
            document.getElementById("nodeId").innerHTML = `Node selected: ${msg.nodeId}`;
            if (msg.shader) {
                loadShaderButton.style.display = "block";
                loadShaderButton.onclick = async () => {
                    clearUniforms();
                    shaderCodeInput.value = msg.shader;
                    for (const shaderUniform of msg.shaderUniforms) {
                        switch (shaderUniform.uniformType) {
                            case "float":
                                if (shaderUniform.extras) {
                                    createShaderFloatUniform(shaderUniform.uniformName, shaderUniform.uniformValue,
                                        shaderUniform.extras.min, shaderUniform.extras.max);
                                } else {
                                    createShaderFloatUniform(shaderUniform.uniformName, shaderUniform.uniformValue,
                                        Math.min(0, shaderUniform.uniformValue), Math.max(1, shaderUniform.uniformValue));
                                }
                                break;
                            case "float2":
                            case "float3":
                            case "float4":
                                createShaderFloatArrayUniform(shaderUniform.uniformName, shaderUniform.uniformType, shaderUniform.uniformValue);
                                break;
                            case "color3":
                            case "color4":
                                createShaderColorUniform(shaderUniform.uniformName, shaderUniform.uniformType, shaderUniform.uniformValue);
                                break;
                            case "int":
                                createShaderIntUniform(shaderUniform.uniformName, shaderUniform.uniformValue);
                                break;
                        }
                        console.log(`${shaderUniform.uniformName} ${shaderUniform.uniformType} = ${shaderUniform.uniformValue}`);
                    }
                    await runShader();
                };
            } else {
                loadShaderButton.style.display = "none";
            }

            shaderWidth = msg.size.width;
            shaderHeight = msg.size.height;
            canvas.width = shaderWidth;
            canvas.height = shaderHeight;
            await runShader();
            return;
        }
    }
</script>
