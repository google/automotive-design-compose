<!--
 Copyright 2024 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/thomas-lowry/figma-plugin-ds/dist/figma-plugin-ds.css" />
    <link rel="stylesheet" href="style.css" />
    <script src="https://unpkg.com/canvaskit-wasm/bin/canvaskit.js"></script>
</head>

<!-- BEGIN OF SHADER PLUGIN UI -->
<div class="page-padding-large">
    <div style="align-items: flex-start; gap: 16px; display: flex;">
        <div>
            <canvas id="shaderPreview" width="256px" height="256px" style="border: 1px black solid" />
        </div>
        <div style="width: 100%; max-height: 256px; overflow-y: scroll;">
            <div style="border: 2px black solid;">
                <div>
                    <div style="height: 32px;" class="center-vertically-container">uniform float3 iResolution;</div>
                    <div style="border-top: 1px black solid; height: 32px;" class="center-vertically-container">uniform
                        float iTime;</div>
                </div>
                <div id="uniforms"></div>
            </div>
            <div style="margin-top: 8px;" class="hug-width-container">
                <span class="icon-button" onclick="createFloatUniform()">
                    <span class="icon icon--plus"></span>
                </span>
                <span>Float Uniform</span>
            </div>
        </div>
    </div>
    <div style="display:flex; flex-wrap: wrap; overflow-y: auto; gap: 4px; margin-top: 8px;">
        <button class="button--primary" onclick="loadShaderCode('julia')">Julia</button>
        <button class="button--primary" onclick="loadShaderCode('cloudy_sky')">CloudySky</button>
        <button class="button--primary" onclick="loadShaderCode('discrete_ocean')">DiscreteOcean</button>
        <button class="button--primary" onclick="loadShaderCode('fibonacci_sphere')">FibonacciSphere</button>
        <button class="button--primary" onclick="loadShaderCode('gradient')">Gradient</button>
        <button class="button--primary" onclick="loadShaderCode('star')">Star</button>
        <button class="button--primary" onclick="clearShaderCode()">CUSTOM</button>
    </div>

    <div style="margin-top: 8px; display: flex;">
        <textarea id="shaderCodeInput" name="shaderCodeInput" style="width: 100%;" rows="12"
            placeholder="Enter your shader code"></textarea>
        <button id="previewShaderButton" class="button--primary" onclick="runShader()">Preview</button>
    </div>

    <div id="nodeSection" class="collapsible" style="margin-top: 8px;">
        <div id="cleared">No nodes selected. Select a node that can have a background to start.</div>
        <div id="selected"></div>
    </div>
    <div id="nodeActions" class="content">
        <div style="display: flex; align-items: center; gap:4px;">
            <div style="width: 100%;">
                <input id="useShaderFallbackColor" type="checkbox" checked="true"></input>
                <span class="tooltip">
                    <img src="images/dials/info-blue.svg">
                    <span class="tooltiptext left-20">When unchecked, DesignCompose will draw the background image from
                        the figma node.</span>
                </span>
                Use the solid color <span style="background-color: #FF46A2;">#FF46A2</span> as background when shader is
                not supported on lower sdks.
            </div>
            <button id="setShaderButton" class="button--primary tooltip">Apply Shader
                <span class="tooltiptext left-80">Use the runtime shader to render the background. It only works on
                    Android 13+.</span></button>
        </div>
        <hr />
        <div style="margin-top: 4px; display: flex; gap:4px; align-items: center;">
            <div style="width: 100%;">
                When clear shader, shader preview image will be removed. If a text has no background after shader
                preview image gets removed, we will set the text color to the solid color <span
                    style="background-color: #FF46A2;">#FF46A2</span>.
            </div>
            <button id="clearShaderButton" class="button--primary" onclick="clearShaderFromFigmaNode()">Clear
                Shader</button>
        </div>
    </div>

    <hr />
    <div>
        Shader examples are from:
        <li><a target="_blank" href="https://shaders.skia.org/">https://shaders.skia.org/</a></li>
        <li><a target="_blank" href="https://godotshaders.com/">https://godotshaders.com/</a></li>
    </div>

    <div style="margin-top: 4px">
        This tool is developed using Skia CanvasKit, please use
        <a target="_blank" href="https://shaders.skia.org/">https://shaders.skia.org/</a> to debug.
    </div>

    <dialog>
        <div>Create float uniform:</div>
        <p>
            <div style="display: flex; gap: 8px;">
            <label for="newUniformName" style="flex-grow: 1;">Name:</label>
            <input type="text" id="newUniformName" placeholder="iFloat" autofocus></input>
        </div>
        <div style="display: flex;gap: 8px;">
            <label for="min" style="flex-grow: 1;">Min:</label>
            <input type="number" id="min" placeholder="0" step="0.1"></input>
        </div>
        <div style="display: flex;gap: 8px;">
            <label for="max" style="flex-grow: 1;">Max:</label>
            <input type="number" id="max" placeholder="1" step="0.1"></input>
        </div>
        </p>
        <div style="display: flex; gap: 4px;">
            <button id="createButton" class="button--primary" style="flex-grow: 1;">Create</button>
            <button id="closeButton" class="button--primary" style="flex-grow: 1;">Close</button>
        </div>
    </dialog>

</div>
<!-- END OF SHADER PLUGIN UI -->

<script>
    let canvas = document.getElementById("shaderPreview");
    let shaderCodeInput = document.getElementById("shaderCodeInput");

    let nodeSection = document.getElementById("nodeSection");
    let nodeCleared = document.getElementById("cleared");
    let nodeSelected = document.getElementById("selected");
    let nodeActions = document.getElementById("nodeActions");
    let setShaderButton = document.getElementById("setShaderButton");
    let useShaderFallbackColor = document.getElementById("useShaderFallbackColor");
    let clearShaderButton = document.getElementById("clearShaderButton");

    let currentShader = null;

    let currentImageSnapshot = null;

    const floatUniforms = [];
    const uniforms = document.getElementById("uniforms");

    const createUniformDialog = document.querySelector("dialog");
    const createButton = document.getElementById("createButton");
    const closeButton = document.getElementById("closeButton");
    const uniformNameInput = document.getElementById("newUniformName");
    const uniformMin = document.getElementById("min");
    const uniformMax = document.getElementById("max");

    // "Create" button closes the dialog and creates the uniform
    createButton.addEventListener("click", () => {
        const uniformName = uniformNameInput.value;
        if (floatUniforms.includes(uniformName)) {
            alert("This uniform already exists, please use a different name.");
            return;
        }
        const regex = /^[a-zA-Z_].*$/;
        if (uniformName.length == 0 || !uniformName.match(regex)) {
            alert("Invalid uniform name, please use a different name");
            return;
        }
        floatUniforms.push(uniformName);

        const newUniformEntry = document.createElement("div");
        newUniformEntry.style.borderTop="1px solid black";

        const shaderLine = document.createElement("div");
        shaderLine.classList.add("center-vertically-container");
        const shaderCode = document.createElement("span");
        shaderCode.textContent = `uniform float ${uniformName};`;
        shaderLine.appendChild(shaderCode);

        const deleteButton = document.createElement("span");
        deleteButton.classList.add("icon-button");
        const deleteIcon = document.createElement("span");
        deleteIcon.classList.add("icon");
        deleteIcon.classList.add("icon--close");
        deleteButton.appendChild(deleteIcon);
        deleteButton.onclick = e => {
            const index = floatUniforms.indexOf(uniformName);
            floatUniforms.splice(index, 1);
            uniforms.removeChild(newUniformEntry);

            runShader();
        };
        shaderLine.appendChild(deleteButton);
        newUniformEntry.appendChild(shaderLine);

        const sliderLine = document.createElement("div");
        sliderLine.classList.add("center-vertically-container");
        const uniformSlider = document.createElement("input");
        uniformSlider.id = `slider_${uniformName}`;
        uniformSlider.classList.add("slider");
        uniformSlider.type = "range";
        const minValue = uniformMin.value ? Number(uniformMin.value) : 0;
        uniformSlider.min = minValue;
        const maxValue = Math.max(uniformMax.value ? Number(uniformMax.value) : 1, minValue + 1);
        uniformSlider.max = maxValue;
        uniformSlider.step = "0.001";
        uniformSlider.value = (minValue + maxValue) / 2;
        sliderLine.appendChild(uniformSlider);

        const uniformValue = document.createElement("span");
        uniformValue.innerHTML = uniformSlider.value;
        uniformSlider.oninput = function () {
            uniformValue.innerHTML = this.value;
        }
        sliderLine.appendChild(uniformValue);
        newUniformEntry.appendChild(sliderLine);
        uniforms.appendChild(newUniformEntry);

        createUniformDialog.close();
        runShader();
    });

    closeButton.addEventListener("click", () => {
        createUniformDialog.close();
    });

    function createFloatUniform() {
        createUniformDialog.showModal();
    }

    function clearFloatUniforms() {
        floatUniforms.length = 0;
        uniforms.innerHTML = "";
    }

    function clearShaderFromFigmaNode() {
        parent.postMessage({
            pluginMessage: {
                msg: 'clearShader',
            }
        }, '*');
    }

    function clearShaderCode() {
        clearFloatUniforms();
        shaderCodeInput.value = `
vec4 main(float2 fragCoord) {
    return vec4(0, 0, 0, 1);
}`;
        currentShader = null;
        runShader();
    }

    function loadShaderCode(shader) {
        clearFloatUniforms();
        parent.postMessage({
            pluginMessage: {
                msg: 'loadShaderCode',
                shader: shader,
            }
        }, '*');
    }

    async function runShader() {
        CanvasKitInit({
            locateFile: (file) =>
                "https://unpkg.com/canvaskit-wasm@latest/bin/" + file,
        }).then((CanvasKit) => {
            const shaderWidth = 256;
            const shaderHeight = 256;

            const paint = new CanvasKit.Paint();
            const startTimeMs = Date.now();
            let mouseClickX = 0;
            let mouseClickY = 0;
            let mouseDragX = 0;
            let mouseDragY = 0;
            let lastMousePressure = 0;

            let extraUniforms = "////// User supplied inputs ////// \n";
            floatUniforms.forEach(function (uniform) {
                extraUniforms += `uniform float ${uniform};\n`;
            });
            extraUniforms += "////// End of user supplied inputs ////// \n";

            const prog = `
// Inputs supplied by shaders.skia.org:
uniform float3 iResolution;      // Viewport resolution (pixels)
uniform float  iTime;            // Shader playback time (s)
uniform float4 iMouse;           // Mouse drag pos=.xy Click pos=.zw (pixels)
` + extraUniforms + shaderCodeInput.value;

            console.log(prog);

            const effect = CanvasKit.RuntimeEffect.Make(prog);
            if (!effect) {
                throw "Can not compile..."
            }

            // Create new surface only when the shader code compiles fine.
            let surface = CanvasKit.MakeCanvasSurface(canvas.id);
            if (!surface) {
                throw "Could not make surface";
            }
            const skcanvas = surface.getCanvas();

            function drawFrame(canvas) {
                const iTime = (Date.now() - startTimeMs) / 1000;
                const uniforms = [
                    shaderWidth, shaderHeight, 1, // vec3 iResolution(x, y, z);
                    iTime, // iTime
                    mouseDragX, mouseDragY, mouseClickX, mouseClickY, // iMouse(x, y, z, w)
                ];
                floatUniforms.forEach(function (uniform) {
                    const slider = document.getElementById(`slider_${uniform}`);
                    uniforms.push(slider.value);
                });

                const shader = effect.makeShader(uniforms);
                if (!shader) {
                    throw "Could not make shader";
                }
                paint.setShader(shader);
                skcanvas.drawPaint(paint);
                shader.delete();

                currentShader = prog;

                // Have to make image snapshot in draw frame to capture an image successfully.
                // Simply calling make image snapshot when clicking on the set shader button only
                // captures an empty image.
                if (currentImageSnapshot != null) {
                    currentImageSnapshot.delete();
                }
                currentImageSnapshot = surface.makeImageSnapshot();

                surface.requestAnimationFrame(drawFrame);
            }
            surface.requestAnimationFrame(drawFrame);

            canvas.addEventListener("pointermove", (e) => {
                if (e.pressure && !lastMousePressure) {
                    mouseClickX = e.offsetX;
                    mouseClickY = e.offsetY;
                }
                lastMousePressure = e.pressure;
                if (!e.pressure) {
                    return;
                }
                mouseDragX = e.offsetX;
                mouseDragY = e.offsetY;
            });

            setShaderButton.onclick = e => {
                if (currentShader != null) {
                    const floatUniformValueMap = new Map();
                    floatUniforms.forEach(function (uniform) {
                        const slider = document.getElementById(`slider_${uniform}`);
                        floatUniformValueMap.set(uniform, slider.value);
                    });
                    const color = useShaderFallbackColor.checked ? "#FF46A2" : undefined;
                    parent.postMessage({
                        pluginMessage: {
                            msg: 'setShader',
                            shader: currentShader,
                            shaderFallbackColor: color,
                            shaderFloatUniforms: Array.from(floatUniformValueMap),
                        }
                    }, '*');
                } else {
                    console.error("There is no shader running....");
                }

                const skImage = surface.makeImageSnapshot();
                if (skImage != null) {
                    parent.postMessage({
                        pluginMessage: {
                            msg: 'insertImage',
                            imageBytes: skImage.encodeToBytes(),
                        }
                    }, '*');
                    skImage.delete();
                } else {
                    console.error("There is no image captured...");
                }

            };
        }); ////// END OF CANVAS KIT //////
    }

    loadShaderCode('julia');

    function showModal() {
        var modal = document.getElementById("shaderInfo");
        modal.style.display = "block";
    }

    window.onmessage = async function (event) {
        let msg = event.data.pluginMessage;
        if (msg.msg == 'shaderCode') {
            shaderCodeInput.value = msg.code;
            await runShader();
            return;
        }

        if (msg.msg == 'shader-selection-cleared') {
            nodeSection.classList.remove("active");
            nodeCleared.style.display = "block";
            nodeSelected.style.display = "none";
            nodeActions.style.display = "none";
            return;
        }
        if (msg.msg == "shader-selection") {
            nodeCleared.style.display = "none";
            nodeSelected.innerHTML = `Node selected: ${msg.nodeId}`;
            nodeSelected.style.display = "block";
            nodeSection.classList.add("active");
            nodeActions.style.display = "block";
            return;
        }
    }
</script>
