<!--
 Copyright 2023 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/thomas-lowry/figma-plugin-ds/dist/figma-plugin-ds.css" />
  <link rel="stylesheet" href="style.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
</head>

<div id="errors" class="page page-padding-small" style="overflow-y: hidden; overflow-x: hidden">
  <div id="errorsMissingKeywords" style="display: none;">
    <span style="font-size: 14">Keywords document not found. Run the "Check/update keyword" plugin to upload a keyword
      document.</span>
  </div>
  <div id="errorList" style="display: block; overflow-y: hidden; overflow-x: hidden"></div>
</div>

<div id="keywords" class="page">
  <div style="display: flex; padding-left:0px; justify-content:left; align-items:center">
    <span class="label" style="width: 100px">File:</span>
    <span class="label" id="keywordsFilename" style="font-size: 14; color: black">Media.json</span>
  </div>
  <div style="display: flex; padding-left:0px; justify-content:left; align-items:center">
    <span class="label" style="width: 100px">Name:</span>
    <span class="label" id="keywordsName" style="font-size: 14; color: black">Media</span>
  </div>
  <div style="display: flex; padding-left:0px; justify-content:left; align-items:center">
    <span class="label" style="width: 100px">Version:</span>
    <span class="label" id="keywordsVersion" style="font-size: 14; color: black">1.0</span>
  </div>
  <div style="margin-left: 8px; margin-top:10px">
    <label for="jsonInputFile" style="padding: 3px; border:black; border-width: 2px; border-style: solid;">Upload new
      keywords file</label>
    <input type="file" id="jsonInputFile" name="json_file" accept="*.txt, *.json" class="hidden">
  </div>
</div>

<div id="meters" class="page">
  <div style="margin-left:12; margin-top: 14">
    <span class="descriptionlabel">Use Figma’s tools to create a gauge or dial. Use one of the options below to define
      live functionality.</span>
  </div>
  <hr class="separator-large" color="#D7D7D7" size="1">
  <div id="arcSection" onchange="arcChanged()" style="margin-top: 24; margin-left: 12; margin-bottom: 40">
    <div style="display: flex; align-items: center; ">
      <label class="switchimg">
        <input id="arcSwitch" type="checkbox">
        <span class="sliderimg round"></span>
      </label>
      <img src="images/dials/icon-arc-path.svg" style="margin-left: 20">
      <div style="margin-left: 20; display: block">
        <span class="boldlabel">Arc path</span><br>
        <span class="sublabel">Select an ellipse or <a
            href="https://help.figma.com/hc/en-us/articles/360040450173-Arc-tool-create-arcs-semi-circles-and-rings"
            target="_blank">arc</a>.</span>
      </div>
    </div>
    <div id="arcControls" style="margin-left:58; display:none">
      <div style="display: flex; margin-top: 8">
        <div style="display: flex; align-items: center">
          <label for="arcStart" class="normallabel">Start</label>
          <input id="arcStart" type="input" style="width: 40;" class="input__field" value="0"
            onkeydown="inputKeyDown(this, NaN, NaN, arcChanged)">
        </div>
        <div style="display: flex; align-items: center; margin-left: 30">
          <label for="arcEnd" class="normallabel">End</label>
          <input id="arcEnd" type="input" style="width: 40;" class="input__field" value="360"
            onkeydown="inputKeyDown(this, NaN, NaN, arcChanged)">
        </div>
      </div>
      <div style="display: flex; margin-top: 2">
        <div class="checkbox" style="margin-left: -3">
          <input id="arcDiscreteSwitch" type="checkbox" class="checkbox">
          <label class="normallabel" style="margin-left: 6">Use incremental stops</label>
        </div>
        <input id="arcDiscreteValue" type="input" style="width: 40;" class="input__field" value="20"
          onkeydown="inputKeyDown(this, 1, NaN, arcChanged)">
      </div>
      <div class="slidecontainer" style="display: flex; margin-top: 10; margin-bottom: -10;">
        <span class="sublabel">Preview</span>
        <div>
          <input id="arcValue" type="range" min="0" max="100" value="50" class="slider" list="arcStepList"
            style="margin-left: 8; margin-top: -3" oninput="arcChanged();">
          <datalist id="arcStepList"></datalist>
          <div id="arcTicks" class="sliderticks"></div>
        </div>
        <span id="arcValuePercent" class="sublabel" style="margin-left: 8"></span>
      </div>
    </div>
  </div>
  <hr class="separator-large" color="#D7D7D7" size="1">

  <div id="rotationSection" onchange="rotationChanged()" style="margin-top: 24; margin-left: 12; margin-bottom: 40">
    <div style="display: flex; align-items: center; ">
      <label class="switchimg">
        <input id="rotationSwitch" type="checkbox">
        <span class="sliderimg round"></span>
      </label>
      <img src="images/dials/icon-rotation-needle.svg" style="margin-left: 20">
      <div style="margin-left: 20; display: block">
        <div style="display: flex">
          <span class="boldlabel">Rotation / needle</span>
          <div style="margin-top: 3">
            <a href="#" onclick="toggleOverlay(rotationOverlay, 'rotation')">
              <img src="images/dials/info-grey.svg" id="rotationInfoGrey" style="margin-left:2; margin-bottom: -3">
              <img src="images/dials/info-blue.svg" id="rotationInfoBlue"
                style="margin-left:2; margin-bottom: -3; display: none">
            </a>
            <div id="rotationOverlay" class="modal" onclick="toggleOverlay(rotationOverlay, 'rotation');">
              <img src="images/dials/overlay-tooltip-rotation.png">
            </div>
          </div>
        </div>
        <span class="sublabel">Select a frame or shape.</span>
      </div>
    </div>
    <div id="rotationControls" style="margin-left:58; display:none">
      <div style="display: flex; margin-top: 8">
        <div style="display: flex; align-items: center">
          <label for="rotationStart" class="normallabel">Start</label>
          <input id="rotationStart" type="input" style="width: 40;" class="input__field" value="0"
            onkeydown="inputKeyDown(this, NaN, NaN, rotationChanged)">
        </div>
        <div style="display: flex; align-items: center; margin-left: 30">
          <label for="rotationEnd" class="normallabel">End</label>
          <input id="rotationEnd" type="input" style="width: 40;" class="input__field" value="360"
            onkeydown="inputKeyDown(this, NaN, NaN, rotationChanged)">
        </div>
      </div>
      <div style="display: flex; margin-top: 2">
        <div class="checkbox" style="margin-left: -3">
          <input id="rotationDiscreteSwitch" type="checkbox" class="checkbox">
          <label class="normallabel" style="margin-left: 6">Use incremental stops</label>
        </div>
        <input id="rotationDiscreteValue" type="input" style="width: 40;" class="input__field" value="20"
          onkeydown="inputKeyDown(this, 1, NaN, rotationChanged)">
      </div>
      <div class="slidecontainer" style="display: flex; margin-top: 10; margin-bottom: -10">
        <span class="sublabel">Preview</span>
        <div>
          <input id="rotationValue" type="range" min="0" max="100" value="50" class="slider" list="rotationStepList"
            style="margin-left: 8; margin-top: -3" oninput="rotationChanged();">
          <datalist id="rotationStepList"></datalist>
          <div id="rotationTicks" class="sliderticks"></div>
        </div>
        <span id="rotationValuePercent" class="sublabel" style="margin-left: 8"></span>
      </div>
    </div>
  </div>
  <hr class="separator-large" color="#D7D7D7" size="1">

  <div id="progressBarSection" onchange="barChanged()" style="margin-top: 24; margin-left: 12; margin-bottom: 40">
    <div style="display: flex; align-items: center;">
      <label class="switchimg">
        <input id="barSwitch" type="checkbox">
        <span class="sliderimg round"></span>
      </label>
      <img src="images/dials/icon-progress-fill.svg" style="margin-left: 20">
      <div style="margin-left: 20; display: block; width: 220">
        <div style="display: flex">
          <span class="boldlabel">Progress bar fill</span>
          <div style="margin-top: 3">
            <a href="#" onclick="toggleOverlay(progressBarOverlay, 'progressBar')">
              <img src="images/dials/info-grey.svg" id="progressBarInfoGrey" style="margin-left:4; margin-bottom: -3">
              <img src="images/dials/info-blue.svg" id="progressBarInfoBlue"
                style="margin-left:4; margin-bottom: -3; display: none">
            </a>
            <div class="modal" id="progressBarOverlay" onclick="toggleOverlay(progressBarOverlay, 'progressBar')">
              <img src="images/dials/overlay-tooltip-progress-bar.png">
            </div>
          </div>
        </div>
        <span class="sublabel" style="width:100">Select a rectangle in a frame.</span>
      </div>
    </div>
    <div id="barControls" style="margin-left:58; display:none">
      <div style="margin-top: 10">
        <div style="display: flex; align-items: center;">
          <div class="directionbox">
            <img id="barHorizontalIcon" src="images/dials/icon-progress-horizontal.svg" style="display: none"
              onclick="barLayoutChanged(false);">
            <img id="barHorizontalSelectedIcon" src="images/dials/icon-progress-horizontal-selected.svg">
            <img id="barVerticalIcon" src="images/dials/icon-progress-vertical.svg" onclick="barLayoutChanged(true);">
            <img id="barVerticalSelectedIcon" src="images/dials/icon-progress-vertical-selected.svg"
              style="display: none">
          </div>
          <label class="normallabel" style="margin-left: 6">Progress bar direction</label>
        </div>
        <div class="checkbox" style="margin-left: -3">
          <input id="barDiscreteSwitch" type="checkbox" class="checkbox">
          <label class="normallabel" style="margin-left: 6">Use incremental stops</label>
        </div>
        <input id="barDiscreteValue" type="input" style="width: 40;" class="input__field" value="20"
          onkeydown="inputKeyDown(this, 1, NaN, barChanged)">
      </div>
      <div class="slidecontainer" style="display: flex; margin-top: 10; margin-bottom: -10">
        <span class="sublabel">Preview</span>
        <div>
          <input id="barValue" type="range" min="0" max="100" value="50" class="slider" list="barStepList"
            style="margin-left: 8; margin-top: -3" oninput="barChanged();">
          <datalist id="barStepList"></datalist>
          <div id="barTicks" class="sliderticks"></div>
        </div>
        <span id="barValuePercent" class="sublabel" style="margin-left: 8"></span>
      </div>
    </div>
  </div>
  <hr class="separator-large" color="#D7D7D7" size="1">

  <div id="progressVectorSection" onchange="vectorChanged()" style="margin-top: 24; margin-left: 12; margin-bottom: 40">
    <div style="display: flex; align-items: center;">
      <label class="switchimg">
        <input id="vectorSwitch" type="checkbox">
        <span class="sliderimg round"></span>
      </label>
      <img src="images/dials/icon-progress-vector.svg" style="margin-left: 20">
      <div style="margin-left: 20; display: block; width: 220">
        <div style="display: flex">
          <span class="boldlabel">Progress vector</span>
          <div style="margin-top: 3">
            <a href="#" onclick="toggleOverlay(progressVectorOverlay, 'progressBar')">
              <img src="images/dials/info-grey.svg" id="progressVectorInfoGrey" style="margin-left:4; margin-bottom: -3">
              <img src="images/dials/info-blue.svg" id="progressVectorInfoBlue"
                style="margin-left:4; margin-bottom: -3; display: none">
            </a>
            <div class="modal" id="progressVectorOverlay" onclick="toggleOverlay(progressVectorOverlay, 'progressBar')">
              <img src="images/dials/overlay-tooltip-progress-vector.png">
            </div>
          </div>
        </div>
        <span class="sublabel" style="width:100">Select a stroked vector with no fill.</span>
      </div>
    </div>
    <div id="vectorControls" style="margin-left:58; display:none">
      <div style="margin-top: 10">
        <div class="checkbox" style="margin-left: -3">
          <input id="vectorDiscreteSwitch" type="checkbox" class="checkbox">
          <label class="normallabel" style="margin-left: 6">Use incremental stops</label>
        </div>
        <input id="vectorDiscreteValue" type="input" style="width: 40;" class="input__field" value="20"
          onkeydown="inputKeyDown(this, 1, NaN, vectorChanged)">
      </div>
    </div>
  </div>
  <hr class="separator-large" color="#D7D7D7" size="1">

  <div id="progressMarkerSection" onchange="markerChanged()" style="margin-top: 24; margin-left: 12; margin-bottom: 40">
    <div style="display: flex; align-items: center;">
      <label class="switchimg">
        <input id="markerSwitch" type="checkbox">
        <span class="sliderimg round"></span>
      </label>
      <img src="images/dials/icon-progress-marker.svg" style="margin-left: 20">
      <div style="margin-left: 20; display: block; width: 220">
        <div style="display: flex">
          <span class="boldlabel">Progress bar marker</span>
          <div style="margin-top: 3">
            <a href="#" onclick="toggleOverlay(progressMarkerOverlay, 'progressMarker')">
              <img src="images/dials/info-grey.svg" id="progressMarkerInfoGrey"
                style="margin-left:4; margin-bottom: -3">
              <img src="images/dials/info-blue.svg" id="progressMarkerInfoBlue"
                style="margin-left:4; margin-bottom: -3; display: none">
            </a>
            <div class="modal" id="progressMarkerOverlay"
              onclick="toggleOverlay(progressMarkerOverlay, 'progressMarker')">
              <img src="images/dials/overlay-tooltip-progress-marker.png">
            </div>
          </div>
        </div>
        <span class="sublabel" style="width:100">Select a framed element in a frame.</span>
      </div>
    </div>
    <div id="markerControls" style="margin-left:58; display:none">
      <div style="margin-top: 10">
        <div style="display: flex; align-items: center;">
          <div class="directionbox">
            <img id="markerHorizontalIcon" src="images/dials/icon-progress-horizontal.svg" style="display: none"
              onclick="markerLayoutChanged(false);">
            <img id="markerHorizontalSelectedIcon" src="images/dials/icon-progress-horizontal-selected.svg">
            <img id="markerVerticalIcon" src="images/dials/icon-progress-vertical.svg"
              onclick="markerLayoutChanged(true);">
            <img id="markerVerticalSelectedIcon" src="images/dials/icon-progress-vertical-selected.svg"
              style="display: none">
          </div>
          <label class="normallabel" style="margin-left: 6">Progress bar direction</label>
        </div>
        <div class="checkbox" style="margin-left: -3">
          <input id="markerDiscreteSwitch" type="checkbox" class="checkbox">
          <label class="normallabel" style="margin-left: 6">Use incremental stops</label>
        </div>
        <input id="markerDiscreteValue" type="input" style="width: 40;" class="input__field" value="20"
          onkeydown="inputKeyDown(this, 1, NaN, markerChanged)">
      </div>
      <div class="slidecontainer" style="display: flex; margin-top: 10; margin-bottom: -10">
        <span class="sublabel">Preview</span>
        <div>
          <input id="markerValue" type="range" min="0" max="100" value="50" class="slider" list="markerStepList"
            style="margin-left: 8; margin-top: -3" oninput="markerChanged();">
          <datalist id="markerStepList"></datalist>
          <div id="markerTicks" class="sliderticks"></div>
        </div>
        <span id="markerValuePercent" class="sublabel" style="margin-left: 8"></span>
      </div>
    </div>
  </div>
  <hr class="separator-large" color="#D7D7D7" size="1">
</div>

<!-- BEGINNING OF LOCALIZATION PLUGIN UI -->
<div id="localizationOptions" class="page page-padding-large">
  <div style="border-bottom: solid #000000; font-weight: bold;">Localization options:</div>
  <div style="margin-top: 8px;">
    <input type="checkbox" id="excludeHashTagName" name="localizationOptions" value="excludeHashTagName" checked>
    <label for="excludeHashTagName">Exclude text nodes whose name starts with '#'</label>
  </div>
  <div style="margin-top: 8px;">
    <input type="checkbox" id="readJsonCustomization" name="localizationOptions" value="readJsonCustomization" checked>
    <label for="readJsonCustomization">If a keywords file was uploaded using "Check/update keywords" menu, use the keywords
      file to localize frames shown on client only and exclude text nodes customized by client.
    </label>
  </div>
  <div style="margin-top: 8px;">
    <input type="checkbox" id="groupSameText" name="localizationOptions" value="groupSameText" checked>
    <label for="groupSameText">Group nodes with same text and use the same string resource name</label>
  </div>
  <div style="display: flex; justify-content: flex-end; align-items: flex-end;"><a href="#uploadStringPanel"
      style="text-decoration: underline;">&nbsp;Next >>&nbsp;</a></div>
</div>
<div id="uploadStringPanel" class="page page-padding-large"
  style="color: black; word-wrap: break-word; margin-top: 16px;">
  <div style="border-bottom: solid #000000; font-weight: bold;">Localization upload options:</div>
  <div style="margin-top: 8px;">Upload an existing gen_strings.xml that is generated by this plugin?</div>
  <div class="container" style="margin-top: 16px;">
    <button class="styled-button">
      <label for="stringsXmlInputFile" style="width: inherit; height: inherit; line-height: 36px;">Browse</label>
      <input type="file" id="stringsXmlInputFile" name="strings_xml_input_file" accept=".xml" class="hidden" />
    </button>
  </div>
  <div id="inputStringsTableContainer" style="display: none; margin-top: 16px; margin-bottom: 16px;">
  </div>
  <div style="display: flex; justify-content: space-between; align-items: flex-end; margin-bottom: 16px;">
    <a href="#localizationOptions" style="text-decoration: underline;">&nbsp;<< Previous&nbsp;</a>
    <a id="showOutputStringsButton" href="#outputStringsPanel" style="text-decoration: underline;"
      onclick="showOutputStrings()">&nbsp;Skip >>&nbsp;</a>
  </div>
</div>

<div id="outputStringsPanel" class="page page-padding-large">
  <div style="border-bottom: solid #000000; font-weight: bold;">Generate the strings xml file:</div>
  <div style="font-size: 14; margin-top: 8px;"><li>Clear the char limit field to set to "NONE".</li></div>
  <div style="font-size: 14; margin-top: 8px;"><li>Uncheck the checkbox in front of the node id to explicitly remove it from localization.</li></div>
  <div style="font-size: 14; margin-top: 8px;"><li>Use the break icon button for a different translation(action not saved, lost on the next run).</li></div>
  <div id="outputStrings" style="margin-top: 16px;">
    <div class="container">
      <div class="loader" id="ouputLoader"></div>
    </div>
  </div>

  <div style="margin-top: 16px;">
    <input type="checkbox" id="includeUnusedStrings" name="includeUnusedStrings" checked />
    <label for="includeUnusedStrings">include unused strings from uploaded file</label>
  </div>

  <div class="container" style="margin-top: 16px;">
    <button id="generateStringsXmlButton" class="styled-button" style="width: 200px;" onclick="generateStringsXML()">
      Generate
    </button>
  </div>
  <div style="display: flex; align-items: flex-end; margin-bottom: 16px;"><a href="#uploadStringPanel"
      style="text-decoration: underline;">
      &nbsp;<< Previous&nbsp;</a>
  </div>
</div>
<!-- END OF LOCALIZATION PLUGIN UI -->

<!-- BEGIN OF IMAGE RES PLUGIN UI -->
<div id="imageExport" class="page page-padding-large">
  <div style="border-bottom: solid #000000; font-weight: bold;">Images:</div>
  <div style="font-size: 14; margin-top: 8px;"><li>Jpg or png images are downloaded in png format, gif images are downloaded in gif format but DesignCompose doesn't support gif.</li></div>
  <hr/>
  <div id="imageInfo"></div>
  <button id="downloadImageButton" class="styled-button" style="width: 200px; margin-top: 16px;">
    Download
  </button>
</div>
<!-- END OF IMAGE RES PLUGIN UI -->

<div id="toast"></div>

<script>
  let jsonInputFile = document.getElementById('jsonInputFile');
  let errorList = document.getElementById('errorList');

  let showOutputStringsButton = document.getElementById('showOutputStringsButton');
  let stringsXmlInputFile = document.getElementById('stringsXmlInputFile');
  let inputStringArray = [];
  let outputStringData = new Map();

  let currentSelection = null;
  let currentNodeType = null;
  let parentNodeType = null;
  let parentSize = { width: 0, height: 0 };

  function showToast(msg, timeout) {
    const toast = document.getElementById("toast");
    toast.textContent = msg;
    // Show the toast.
    toast.classList.add("show");

    if (timeout) {
      // Then hide after 2s.
      setTimeout(() => {
        toast.classList.remove("show");
      }, 2000);
    }
  }

  function hideToast() {
    clearTimeout();
    toast.classList.remove("show");
  }

  function toNumber(str, def) {
    let num = parseInt(str, 10);
    if (isNaN(num)) {
      return def;
    }
    return num;
  }

  function jsonInputFileChanged() {
    let selectedFile = jsonInputFile.files[0];
    const reader = new FileReader();
    reader.addEventListener("loadend", e => {
      parent.postMessage({
        pluginMessage: {
          msg: 'clippy-file-selected',
          fileName: selectedFile.name,
          contents: reader.result.toString()
        }
      }, '*');
    })
    reader.readAsText(selectedFile);
  }

  function updateMeterDisabledStates() {
    let allowRotation = !arcSwitch.checked && !barSwitch.checked && !markerSwitch.checked && !vectorSwitch.checked;
    let allowArc = currentNodeType == "ELLIPSE" && !rotationSwitch.checked && !barSwitch.checked && !markerSwitch.checked && !vectorSwitch.checked;
    let hasParentFrame = parentNodeType == "FRAME";
    let allowProgress = (currentNodeType == "FRAME" || currentNodeType == "RECTANGLE") && hasParentFrame
    let allowBar = hasParentFrame && allowProgress && !rotationSwitch.checked && !arcSwitch.checked && !markerSwitch.checked && !vectorSwitch.checked;
    let allowVector = currentNodeType == "VECTOR" && !rotationSwitch.checked && !arcSwitch.checked && !barSwitch.checked && !markerSwitch.checked;
    let allowMarker = hasParentFrame && allowProgress && !rotationSwitch.checked && !arcSwitch.checked && !barSwitch.checked && !vectorSwitch.checked;

    rotationSwitch.disabled = !allowRotation;
    arcSwitch.disabled = !allowArc;
    barSwitch.disabled = !allowBar;
    vectorSwitch.disabled = !allowVector;
    markerSwitch.disabled = !allowMarker;
  }

  function addDegrees(num) {
    if (num.charAt(num.length - 1) != "°")
      return num + "°"
    return num
  }

  function addPercent(num) {
    if (num.charAt(num.length - 1) != "%")
      return num + "%"
    return num
  }

  function incrementInput(input, min, max, updateFunc) {
    let value = toNumber(input.value) + 1;
    if (!isNaN(min))
      value = Math.max(value, min);
    if (!isNaN(max))
      value = Math.min(value, max);
    input.value = value.toString();
    updateFunc();
  }

  function decrementInput(input, min, max, updateFunc) {
    let value = toNumber(input.value) - 1;
    if (!isNaN(min))
      value = Math.max(value, min);
    if (!isNaN(max))
      value = Math.min(value, max);
    input.value = value.toString();
    updateFunc();
  }

  function inputKeyDown(input, min, max, updateFunc) {
    switch (event.keyCode) {
      case 38: // Up key
        incrementInput(input, min, max, updateFunc);
        break;
      case 40: // Down key
        decrementInput(input, min, max, updateFunc);
        break;
    }
  }

  function clearChildren(element) {
    if (!element)
      return;

    while (element.firstChild) {
      element.removeChild(element.lastChild);
    }
  }

  function makeStepList(stepList, tickList, startInput, endInput, discreteSwitch, discreteInput) {
    const start = toNumber(startInput.value);
    const end = toNumber(endInput.value);
    makeStepListValues(stepList, tickList, start, end, discreteSwitch, discreteInput);
  }

  function makeStepListValues(stepList, tickList, start, end, discreteSwitch, discreteInput) {
    clearChildren(stepList);
    clearChildren(tickList);

    const incr = discreteSwitch.checked ? toNumber(discreteInput.value) : 0;
    if (incr == 0)
      return;

    let range = Math.abs(end - start);
    let numStops = range / incr;
    let maxStops = tickList ? tickList.offsetWidth : Number.MAX_SAFE_INTEGER;
    if (numStops > maxStops)
      return;

    for (var i = 0; i <= numStops; ++i) {
      let stop = document.createElement("OPTION");
      let value = Math.round(i / numStops * 100);
      stop.setAttribute("value", value);
      stepList.appendChild(stop);

      if (tickList != null) {
        let tick = document.createElement("div");
        tick.classList.add("tick");
        tickList.appendChild(tick);
      }
    }
  }

  function arcInputFormat() {
    arcStart.value = addDegrees(arcStart.value);
    arcEnd.value = addDegrees(arcEnd.value);
    arcDiscreteValue.value = addDegrees(arcDiscreteValue.value);
    arcValuePercent.textContent = addPercent(arcValue.value.toString());
    makeStepList(arcStepList, arcTicks, arcStart, arcEnd, arcDiscreteSwitch, arcDiscreteValue);
  }

  function arcChanged() {
    updateMeterDisabledStates();
    arcControls.style.display = arcSwitch.checked ? 'block' : 'none';
    arcDiscreteValue.style.display = arcDiscreteSwitch.checked ? 'block' : 'none';
    arcInputFormat();

    parent.postMessage({
      pluginMessage: {
        msg: 'arc-changed',
        enabled: arcSwitch.checked,
        start: toNumber(arcStart.value, 0),
        end: toNumber(arcEnd.value, 0),
        value: toNumber(arcValue.value, 0),
        discrete: arcDiscreteSwitch.checked,
        discreteValue: toNumber(arcDiscreteValue.value, 20),
      }
    }, '*');
  }

  function toggleOverlay(overlay, infoButtonPrefix) {
    overlay.style.display = overlay.style.display == "flex" ? "none" : "flex";

    var greyButton = document.getElementById(infoButtonPrefix + "InfoGrey");
    var blueButton = document.getElementById(infoButtonPrefix + "InfoBlue");
    greyButton.style.display = greyButton.style.display == "none" ? "block" : "none";
    blueButton.style.display = blueButton.style.display == "none" ? "block" : "none";

    if (overlay.style.display == "none") {
      openPage('meters');
    }
  }

  function rotationInputFormat() {
    rotationStart.value = addDegrees(rotationStart.value);
    rotationEnd.value = addDegrees(rotationEnd.value);
    rotationDiscreteValue.value = addDegrees(rotationDiscreteValue.value);
    rotationValuePercent.textContent = addPercent(rotationValue.value.toString());
    makeStepList(rotationStepList, rotationTicks, rotationStart, rotationEnd, rotationDiscreteSwitch, rotationDiscreteValue);
  }

  function rotationChanged() {
    updateMeterDisabledStates();
    rotationControls.style.display = rotationSwitch.checked ? 'block' : 'none';
    rotationDiscreteValue.style.display = rotationDiscreteSwitch.checked ? 'block' : 'none';
    rotationInputFormat();

    parent.postMessage({
      pluginMessage: {
        msg: 'rotation-changed',
        enabled: rotationSwitch.checked,
        start: toNumber(rotationStart.value, 0),
        end: toNumber(rotationEnd.value, 0),
        value: toNumber(rotationValue.value, 0),
        discrete: rotationDiscreteSwitch.checked,
        discreteValue: toNumber(rotationDiscreteValue.value, 20),
      }
    }, '*');
  }

  function setBarLayout(vertical) {
    barHorizontalIcon.style.display = vertical ? 'block' : 'none';
    barHorizontalSelectedIcon.style.display = vertical ? 'none' : 'block';
    barVerticalIcon.style.display = vertical ? 'none' : 'block';
    barVerticalSelectedIcon.style.display = vertical ? 'block' : 'none';
  }

  function barInputFormat() {
    barDiscreteValue.value = addPercent(barDiscreteValue.value);
    barValuePercent.textContent = addPercent(barValue.value.toString());
    makeStepListValues(barStepList, barTicks, 0, 100, barDiscreteSwitch, barDiscreteValue);
  }

  function barLayoutChanged(vertical) {
    setBarLayout(vertical);
    barChanged();
  }

  function barChanged() {
    updateMeterDisabledStates();
    barControls.style.display = barSwitch.checked ? 'block' : 'none';
    barDiscreteValue.style.display = barDiscreteSwitch.checked ? 'block' : 'none';
    barInputFormat();

    const vertical = barVerticalSelectedIcon.style.display != 'none';
    parent.postMessage({
      pluginMessage: {
        msg: 'bar-changed',
        enabled: barSwitch.checked,
        value: toNumber(barValue.value, 0),
        discrete: barDiscreteSwitch.checked,
        discreteValue: toNumber(barDiscreteValue.value, 20),
        vertical: vertical,
      }
    }, '*');
  }


  function vectorInputFormat() {
    vectorDiscreteValue.value = addPercent(vectorDiscreteValue.value);
  }

  function vectorChanged() {
    updateMeterDisabledStates();
    vectorControls.style.display = vectorSwitch.checked ? 'block' : 'none';
    vectorDiscreteValue.style.display = vectorDiscreteSwitch.checked ? 'block' : 'none';
    vectorInputFormat();

    const vertical = barVerticalSelectedIcon.style.display != 'none';
    parent.postMessage({
      pluginMessage: {
        msg: 'vector-changed',
        enabled: vectorSwitch.checked,
        //value: toNumber(vectorValue.value, 0),
        discrete: vectorDiscreteSwitch.checked,
        discreteValue: toNumber(vectorDiscreteValue.value, 20),
        vertical: vertical,
      }
    }, '*');
  }


  function setMarkerLayout(vertical) {
    markerHorizontalIcon.style.display = vertical ? 'block' : 'none';
    markerHorizontalSelectedIcon.style.display = vertical ? 'none' : 'block';
    markerVerticalIcon.style.display = vertical ? 'none' : 'block';
    markerVerticalSelectedIcon.style.display = vertical ? 'block' : 'none';
  }

  function markerInputFormat() {
    markerDiscreteValue.value = addPercent(markerDiscreteValue.value);
    markerValuePercent.textContent = addPercent(markerValue.value.toString());
    makeStepListValues(markerStepList, markerTicks, 0, 100, markerDiscreteSwitch, markerDiscreteValue);
  }

  function markerLayoutChanged(vertical) {
    setMarkerLayout(vertical);
    markerChanged();
  }

  function markerChanged() {
    updateMeterDisabledStates();
    markerControls.style.display = markerSwitch.checked ? 'block' : 'none';
    markerDiscreteValue.style.display = markerDiscreteSwitch.checked ? 'block' : 'none';
    markerInputFormat();

    const vertical = markerVerticalSelectedIcon.style.display != 'none';
    parent.postMessage({
      pluginMessage: {
        msg: 'marker-changed',
        enabled: markerSwitch.checked,
        value: toNumber(markerValue.value, 0),
        discrete: markerDiscreteSwitch.checked,
        discreteValue: toNumber(markerDiscreteValue.value, 20),
        vertical: vertical,
      }
    }, '*');
  }

  function valueToPercent(degrees, min, max) {
    return (degrees - min) / (max - min) * 100;
  }

  function setMeterData(msg) {
    currentNodeType = msg.nodeType;
    parentNodeType = msg.parentType;
    parentSize = msg.parentSize;

    let meterData = msg.meterData;
    let ellipseAngle = msg.ellipseAngle;
    let rotation = msg.rotation;
    let progress = msg.progress;
    let marker = msg.marker;

    let sd = meterData.arcData;
    arcSwitch.disabled = msg.nodeType != "ELLIPSE";
    arcControls.style.display = (sd && sd.enabled) ? 'block' : 'none';
    arcSwitch.checked = sd && sd.enabled;
    let sdStart = sd ? sd.start.toString() : "0";
    let sdEnd = sd ? sd.end.toString() : "360";
    arcStart.value = sdStart;
    arcEnd.value = sdEnd;
    if (ellipseAngle) {
      const percent = valueToPercent(ellipseAngle, sdStart, sdEnd);
      arcValue.value = percent;
    }
    arcDiscreteSwitch.checked = sd && sd.discrete;
    arcDiscreteValue.value = sd ? sd.discreteValue : 20;
    arcDiscreteValue.style.display = (sd && sd.discrete ? 'block' : 'none');
    arcInputFormat();

    let rd = meterData.rotationData;
    rotationSwitch.disabled = false;
    rotationControls.style.display = (rd && rd.enabled) ? 'block' : 'none';
    rotationSwitch.checked = rd && rd.enabled;
    let rdStart = rd ? rd.start.toString() : "0";
    let rdEnd = rd ? rd.end.toString() : "-360";
    rotationStart.value = rdStart;
    rotationEnd.value = rdEnd;
    if (rotation) {
      const percent = valueToPercent(rotation, rdStart, rdEnd);
      rotationValue.value = percent
    }
    rotationDiscreteSwitch.checked = rd && rd.discrete;
    rotationDiscreteValue.value = rd ? rd.discreteValue : 20;
    rotationDiscreteValue.style.display = (rd && rd.discrete) ? 'block' : 'display';
    rotationInputFormat();

    let bd = meterData.progressBarData;
    barSwitch.disabled = (msg.nodeType != "FRAME" && msg.nodeType != "RECTANGLE");
    barControls.style.display = (bd && bd.enabled) ? 'block' : 'none';
    barSwitch.checked = bd && bd.enabled;
    if (progress)
      barValue.value = progress;
    barDiscreteSwitch.checked = bd && bd.discrete;
    barDiscreteValue.value = bd ? bd.discreteValue : 20;
    barDiscreteValue.style.display = (bd && bd.discrete) ? 'block' : 'none';
    setBarLayout(bd && bd.vertical);
    barInputFormat();

    let vd = meterData.progressVectorData;
    vectorSwitch.disabled = msg.nodeType != "VECTOR";
    vectorControls.style.display = (vd && vd.enabled) ? 'block' : 'none';
    vectorSwitch.checked = vd && vd.enabled;
    vectorDiscreteSwitch.checked = vd && vd.discrete;
    vectorDiscreteValue.value = vd ? vd.discreteValue : 20;
    vectorDiscreteValue.style.display = (vd && vd.discrete) ? 'block' : 'none';
    vectorInputFormat();

    let md = meterData.progressMarkerData;
    markerSwitch.disabled = (msg.nodeType != "FRAME" && msg.nodeType != "RECTANGLE");
    markerControls.style.display = (md && md.enabled) ? 'block' : 'none';
    markerSwitch.checked = md && md.enabled;
    if (progress)
      markerValue.value = progress;
    markerDiscreteSwitch.checked = md && md.discrete;
    markerDiscreteValue.value = md ? md.discreteValue : 20;
    markerDiscreteValue.style.display = (md && md.discrete) ? 'block' : 'none';
    setMarkerLayout(md && md.vertical);
    markerInputFormat();

    updateMeterDisabledStates();
  }

  // Localization functions
  function stringsXmlInputFileChanged() {
    let selectedFile = stringsXmlInputFile.files[0];
    const reader = new FileReader();
    reader.addEventListener("loadend", e => {
      try {
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(reader.result.toString(), "text/xml");
        // Clear data.
        inputStringArray.length = 0;

        // Process string
        const strings = xmlDoc.getElementsByTagName("string");
        for (const strElement of strings) {
          var jsonStr = {}
          const name = strElement.getAttribute("name");
          jsonStr["name"] = name;
          const translatable = strElement.getAttribute("translatable") != "false";
          jsonStr["translatable"] = translatable;
          const text = strElement.textContent;
          jsonStr["text"] = text;
          const extras = getDescriptionExtras(strElement);
          jsonStr["extras"] = extras;

          inputStringArray.push(jsonStr);
        }

        const stringArrays = xmlDoc.getElementsByTagName("string-array");

        // Process string-array
        for (let i = 0; i < stringArrays.length; i++) {
          var jsonStr = {}
          const strArrayElement = stringArrays[i];
          jsonStr["name"] = strArrayElement.getAttribute("name");
          const translatable = strArrayElement.getAttribute("translatable") != "false";
          jsonStr["translatable"] = translatable;
          const values = Array.from(strArrayElement.getElementsByTagName("item")).map(
            item => item.textContent);
          jsonStr["text"] = values;
          const extras = getDescriptionExtras(strArrayElement);
          jsonStr["extras"] = extras;
          inputStringArray.push(jsonStr);
        }

        createInputStringTable("inputStringsTableContainer", inputStringArray);
        if (inputStringArray.length == 0) {
          showToast("No strings found in the uploaded xml file.", true);
        }
        showOutputStringsButton.innerHTML = "&nbsp;Next >>&nbsp;";
      } catch (error) {
        showToast("An error occured uploading the strings xml file", true);
        console.error("An error occured uploading the strings xml file", error);
      }
    });
    reader.readAsText(selectedFile);
  }

  function getDescriptionExtras(strElement) {
    const extras = {};
    const description = strElement.getAttribute("description");
    if (description != null) {
      const regex = /(.+)\[CHAR_LIMIT=(.+)\]/;
      const match = description.match(regex);
      if (match) {
        extras["description"] = match[1].trim();
        if (match[2]) {
          extras["charlimit"] = toNumber(match[2], "NONE");
        }
      } else {
        const charlimitRegex = /\[CHAR_LIMIT=(.+)\]/;
        const charlimitMatch = description.match(charlimitRegex);
        if (charlimitMatch) {
          extras["charlimit"] = toNumber(charlimitMatch[1], "NONE");
        } else {
          extras["description"] = description;
        }
      }
    }
    return extras;
  }

  function showOutputStrings() {
    const localizationOptionElements = document.querySelectorAll('input[name="localizationOptions"]:checked');
    const localizationOptions = Array.from(localizationOptionElements).map(checkbox => checkbox.value);

    parent.postMessage({
      pluginMessage: {
        msg: 'generate-localization-data',
        contents: inputStringArray,
        options: localizationOptions,
      }
    }, '*');
  }

  function createTable(tableContainerId) {
    const tableContainer = document.getElementById(tableContainerId);
    tableContainer.style.display = "block";
    tableContainer.innerHTML = "";

    const table = document.createElement("table");
    table.setAttribute("border", "1");
    table.setAttribute("style", "border-collapse: collapse;");
    table.setAttribute("cellpadding", "10");
    table.setAttribute("width", "100%");

    return { table, tableContainer };
  }

  function createTableHeader(table, headers) {
    const headerRow = document.createElement("tr");
    for (const headerText of headers) {
      const th = document.createElement("th");
      th.textContent = headerText;
      headerRow.appendChild(th);
    }
    table.appendChild(headerRow);
  }

  function createCell(cellData, forNodeId) {
    const td = document.createElement("td");
    td.style.maxWidth = "200px";

    if (cellData != null) {
      if (Array.isArray(cellData)) {
        // String array or node id array.
        for (const nestedCellData of cellData) {
          const nestedBlock = document.createElement("div");
          if (forNodeId) {
            let nodeIdElement = createNodeIdElement(nestedCellData, cellData.length == 1);
            nestedBlock.appendChild(nodeIdElement);
          } else {
            nestedBlock.style.overflowWrap = "anywhere";
            nestedBlock.textContent = nestedCellData;
          }
          td.appendChild(nestedBlock);
          if (cellData[cellData.length - 1] != nestedCellData) {
            td.appendChild(document.createElement("hr"));
          }
        }
      } else if (typeof cellData == "object") {
        td.textContent = JSON.stringify(cellData);
      } else {
        td.textContent = cellData;
        td.style.overflowWrap = "anywhere";
      }
    }
    return td;
  }

  function createNodeIdElement(node, isSingleNode) {
    const block = document.createElement('div');

    if (!isSingleNode) {
      const editBtn = document.createElement('span');
      editBtn.style.width = '20px';
      editBtn.style.height = '20px';
      editBtn.style.padding = '0px';
      editBtn.classList.add('icon-button');
      editBtn.addEventListener('mouseover', (event) => {
        showToast('Use the break button for a different translation.', false);
      });
      editBtn.addEventListener('mouseout', (event) => {
        hideToast();
      });
      // Revise the cursor to default to be consistent with the icon below.
      editBtn.style.cursor = 'default';
      const editIcon = document.createElement('span');
      editIcon.classList.add('icon', 'icon--break');
      editIcon.style.width = '16px';
      editIcon.style.height = '16px';
      editBtn.appendChild(editIcon);
      editBtn.onclick = () => {
        parent.postMessage({
          pluginMessage: {
            msg: 'localization-ungroup-node',
            node: node["nodeId"],
            stringResMap: Array.from(outputStringData)
          }
        }, '*');
      };
      block.append(editBtn);
    }

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = !node["isExcluded"];
    checkbox.addEventListener('change', (event) => {
      const excluded = !event.target.checked;
      const message = `Are you sure you want to ${excluded ? "remove this node from" : "add this node to" } localization?`
        let result = confirm(message);
        if (result) {
          // Update the local excluded bit.
          node["isExcluded"] = excluded;
          // Post message to update the figma plugin data.
          parent.postMessage({
            pluginMessage: {
              msg: 'localization-exclude-node',
              node: node["nodeId"],
              excluded: excluded
            }
          }, '*');
        } else {
          // Action canceled, revert the check state.
          checkbox.checked = !checkbox.checked;
          showToast("Action canceled...", true);
        }
    });
    block.appendChild(checkbox);

    let r = createNodeIdSpan(node["nodeId"]);
    block.appendChild(r);
    return block;
  }

  function createNodeIdSpan(nodeId) {
    let r = document.createElement('span');
    r.textContent = nodeId;
    r.style.textDecoration = 'underline';
    r.style.marginInlineStart = '8px';
    r.style.overflowWrap = "anywhere";
    r.onclick = () => {
      parent.postMessage({
        pluginMessage: {
          msg: 'show-node',
          key: 'vsw-show-node',
          node: nodeId
        }
      }, '*');
    };
    return r;
  }

  function createInputStringTable(tableContainerId, inputStringArray) {
    let { table, tableContainer } = createTable(tableContainerId);

    const headers = ["String Resource Name", "Text", "Description", "Translatable"];
    createTableHeader(table, headers);

    for (const stringRes of inputStringArray) {
      var cells = Object.values(stringRes);
      const row = document.createElement("tr");
      row.appendChild(createCell(stringRes["name"], false));
      row.appendChild(createCell(stringRes["text"], false));
      row.appendChild(createDescriptionCell(stringRes));
      row.appendChild(createCell(stringRes["translatable"], false));
      table.appendChild(row);
    }

    tableContainer.appendChild(table);
  }

  function hasLocalizedTextNode(stringRes) {
    return stringRes["textNodes"] != null && stringRes["textNodes"].some(node => node["isExcluded"] == false);
  }

  function createDescriptionCell(stringRes) {
    const td = document.createElement("td");
    td.style.maxWidth = "180px";

    const extras = stringRes["extras"];
    const textLength = stringRes["textLength"];
    if (hasLocalizedTextNode(stringRes)) {
      const form = document.createElement("form");

      const charlimitInput = document.createElement("input");
      charlimitInput.type = "number";
      let { min, max } = getCharLimitRange(textLength);
      charlimitInput.min = min;
      charlimitInput.max = max;
      charlimitInput.step = "5";
      charlimitInput.name = "charlimit";
      charlimitInput.style.width = "100px";
      charlimitInput.placeholder = "NONE";
      if (extras["charlimit"] != "NONE") {
        charlimitInput.value = extras["charlimit"];
      }

      const descriptionInput = document.createElement("input");
      descriptionInput.type = "text";
      descriptionInput.name = "description";
      descriptionInput.placeholder = "Enter description";
      if (extras["description"] != null) {
        descriptionInput.value = extras["description"];
      }

      const submitButton = document.createElement("button");
      submitButton.type = "submit";
      submitButton.textContent = "Submit";

      const charlimitLabel = document.createElement('label');
      charlimitLabel.htmlFor = 'charlimit';
      charlimitLabel.textContent = 'Char limit:';
      form.appendChild(charlimitLabel);
      form.appendChild(document.createElement("br"));
      form.appendChild(charlimitInput);
      form.appendChild(document.createElement("br"));
      const descriptionLabel = document.createElement('label');
      descriptionLabel.htmlFor = 'description';
      descriptionLabel.textContent = 'Description:';
      form.appendChild(descriptionLabel);
      form.appendChild(document.createElement("br"));
      form.appendChild(descriptionInput);
      form.appendChild(document.createElement("br"));
      form.appendChild(submitButton);
      td.appendChild(form);

      form.addEventListener("submit", (event) => {
        event.preventDefault(); // Prevent default form submission
        const charlimit = charlimitInput.value;
        const description = descriptionInput.value;
        extras["charlimit"] = charlimit == 0 ? "NONE" : charlimit;
        extras["description"] = description;
        parent.postMessage({
          pluginMessage: {
            msg: 'update-localization-data',
            item: stringRes
          }
        }, '*');
      });
    } else {
      const textBlock = document.createElement("div");
      textBlock.textContent = formatDescription(extras);
      td.appendChild(textBlock);
    }
    return td;
  }

  function getCharLimitRange(textLength) {
    const min = textLength % 5 === 0 ? textLength : textLength + 5 - textLength % 5;
    const max = Math.max(20, 5 * textLength + 10 - 5 * textLength % 10);
    return { min, max };
  }

  function formatDescription(extras) {
    if (extras) {
      const description = extras["description"];
      const charlimit = extras["charlimit"];
      if (description && charlimit) {
        return `${description} [CHAR_LIMIT=${charlimit}]`;
      } else if (description) {
        return `${description} [CHAR_LIMIT=NONE]`;
      } else if (charlimit) {
        return `[CHAR_LIMIT=${charlimit}]`;
      }
    }
    return "";
  }

  function loadOutputStringData(output) {
    outputStringData.clear();
    for (const [key, stringRes] of output) {
      outputStringData.set(key, stringRes);
    }
  }

  function createOutputStringTable(tableContainerId) {
    let { table, tableContainer } = createTable(tableContainerId);

    const headers = ["String Resource Name", "Text", "Node", "Description", "Translatable"];
    createTableHeader(table, headers);

    for (const [key, stringRes] of outputStringData) {
      const cells = Object.values(stringRes);
      const row = document.createElement("tr");

      if (hasLocalizedTextNode(stringRes)) {
        const td = document.createElement("td");
        td.style.maxWidth = "200px";

        const input = document.createElement("input");
        input.addEventListener('change', function (evt) {
          const newValue = this.value;
          if (outputStringData.has(newValue)) {
            let newStringRes = outputStringData.get(newValue);
            let hasChanged = false;
            // Use toString() to compare string and string array.
            if (stringRes["text"].toString() === newStringRes["text"].toString()) {
              let result = confirm(`Would you like to merge the translations with ${newStringRes["name"]}?`);
              if (result) {
                // Merge the text nodes and upate the UI.
                for (const node of stringRes["textNodes"]) {
                  if (newStringRes["textNodes"]) {
                    newStringRes["textNodes"].push(node);
                  } else {
                    newStringRes["textNodes"] = [node];
                  }
                }
                // Remove the string resource from the map.
                outputStringData.delete(stringRes["name"]);
                // Notify figma to update the plugin data.
                stringRes["name"] = newValue;
                parent.postMessage({
                  pluginMessage: {
                    msg: 'update-localization-data',
                    item: stringRes
                  }
                }, '*');
                // Refresh the table, which recreate the whole table...
                createOutputStringTable('outputStrings');
                hasChanged = true;
              }
            }
            if (!hasChanged) {
              input.value = stringRes["name"];
              showToast(`${newValue} already exists. Reverting resource name since duplicates are not allowed.`, true);
            }
          } else if (stringRes["name"] != this.value) {
            outputStringData.delete(stringRes["name"]);
            stringRes["name"] = this.value;
            outputStringData.set(stringRes["name"], stringRes);
            parent.postMessage({
              pluginMessage: {
                msg: 'update-localization-data',
                item: stringRes
              }
            }, '*');
          }
        });
        input.setAttribute("type", "text");
        input.setAttribute("value", stringRes["name"]);
        td.appendChild(input);
        row.appendChild(td);
      } else {
        row.appendChild(createCell(stringRes["name"], false));
      }
      row.appendChild(createCell(stringRes["text"], false));
      row.appendChild(createCell(stringRes["textNodes"], true));
      row.appendChild(createDescriptionCell(stringRes));
      row.appendChild(createCell(stringRes["translatable"], false));

      table.appendChild(row);
    }

    tableContainer.appendChild(table);
  }

  function generateStringsXML() {
    const checkbox = document.getElementById("includeUnusedStrings");
    let xmlString = '<?xml version="1.0" encoding="UTF-8"?>\n'
    xmlString += '<!-- DO NOT EDIT. AUTO GENERATED BY DESIGN COMPOSE PLUGIN. -->\n'
    xmlString += '<resources>\n';
    for (const [key, output] of outputStringData) {
      if ((checkbox.checked && !output.textNodes) || hasLocalizedTextNode(output)) {
        if (typeof output.text === "string") {
          xmlString += `  <string name="${output.name}"\n`;
          const formattedDescription = formatDescription(output.extras);
          if (formattedDescription.length > 0) {
            xmlString += `    description="${formattedDescription}"\n`;
          } else if (output.translatable) {
            xmlString += `    description="[CHAR_LIMIT=NONE]"\n`;
          }
          xmlString += `    translatable="${output.translatable}">${output.text}</string>\n`;
        } else {
          xmlString += `  <string-array name="${output.name}"\n`;
          const formattedDescription = formatDescription(output.extras);
          if (formattedDescription.length > 0) {
            xmlString += `    description="${formattedDescription}"\n`;
          } else if (output.translatable) {
            xmlString += `    description="[CHAR_LIMIT=NONE]"\n`;
          }
          xmlString += `    translatable="${output.translatable}">\n`;
          for (const item of output.text) {
            xmlString += `    <item>${item}</item>\n`;
          }
          xmlString += '  </string-array>\n';
        }
      }
    }
    xmlString += '</resources>\n';

    const blob = new Blob([xmlString], { type: "text/xml" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = "gen_strings.xml";
    link.click();

    parent.postMessage({
      pluginMessage: {
        msg: 'close-plugin'
      }
    }, '*');
  }

  function openPage(pageId) {
    const link = document.createElement("a");
    link.href = '#' + pageId;
    link.click();
  }

  function bytesToHex(bytes) {
    return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');
  }

  // Read first 4 bytes from the image bytes to determine the image type.
  function getImageType(imageBytes){
    const firstFewBytes = new Uint8Array(imageBytes.buffer, 0, 4);
    const imageSignatures = {
      'ffd8ffe0': 'jpeg',
      'ffd8ffe1': 'jpeg',
      '89504e47': 'png',
      '47494638': 'gif',
    };
    const hexSignature = bytesToHex(firstFewBytes);
    const imageFormat = imageSignatures[hexSignature.toLowerCase()];
    return imageFormat;
  }

  // By sticking it in an HTML canvas and converting into bytes using the canvas, it
  // will be converted to png format.
  async function convert(canvas, ctx, bytes) {
    const url = URL.createObjectURL(new Blob([bytes]));
    const image = await new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => reject();
      img.src = url;
    })
    canvas.width = image.width;
    canvas.height = image.height;
    ctx.drawImage(image, 0, 0);
    return await new Promise((resolve, reject) => {
      canvas.toBlob(blob => {
        const reader = new FileReader();
        reader.onload = () => resolve(new Uint8Array(reader.result));
        reader.onerror = () => reject(new Error('Could not read from blob'));
        reader.readAsArrayBuffer(blob);
      });
    });
  }

  // jpeg and png will be downloaded as png. Gif will be downloaded as gif. Other
  // image types are not supported.
  async function processImage(imageHash, imageBytes) {
    const imageType = getImageType(imageBytes);
    switch(imageType) {
      case 'png':
      case 'jpeg':
        const fileFormat = 'png';
        const canvas = document.createElement('canvas');
        canvas.style.marginTop = '8px';
        const ctx = canvas.getContext('2d');
        const newBytes = await convert(canvas, ctx, imageBytes);
        return {element: canvas, outputImgBytes: newBytes, imageFormat: fileFormat};
      case 'gif':
      default:
        const blob = new Blob([imageBytes], { type: `image/${imageType}` });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        const image = document.createElement('img');
        image.style.marginTop = '8px';
        image.src = url;
        return {element: image, outputImgBytes: imageBytes, imageFormat: imageType};
    }
  }

  // Display the images
  async function createImageOutput(imageNodesArray, imageResNameArray, imageBytesArray, exportedImageHashArray) {
    const imageInfo = document.getElementById('imageInfo');
    imageInfo.innerHTML = "";

    let imageNodesMap = new Map(imageNodesArray);
    let imageResMap = new Map(imageResNameArray);
    let imageOutputMap = new Map();

    for (const [imageHash, imageBytes] of imageBytesArray) {
      const resName = imageResMap.get(imageHash);

      const imageHashElement = document.createElement('div');
      imageHashElement.style.marginTop = '8px';
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.checked = exportedImageHashArray.includes(imageHash);
      imageHashElement.appendChild(checkbox);
      const span = document.createElement('span');
      span.textContent = `Image hash: ${imageHash}`;
      imageHashElement.appendChild(span);
      imageInfo.appendChild(imageHashElement);

      const resNameElement = document.createElement('div');
      resNameElement.style.marginTop = '8px';
      resNameElement.textContent = 'Image res name: ';
      const input = document.createElement("input");
      input.addEventListener('change', function (evt) {
        const newValue = this.value;
        parent.postMessage({
            pluginMessage: {
              msg: 'update-image-res-name',
              imageHash: imageHash,
              resName: newValue
            }
          }, '*');
        });
      input.setAttribute("type", "text");
      input.setAttribute("value", resName);
      resNameElement.appendChild(input);
      imageInfo.appendChild(resNameElement);

      let {element, outputImgBytes, imageFormat} = await processImage(imageHash, imageBytes);
      imageInfo.appendChild(element);

      if (exportedImageHashArray.includes(imageHash)) {
        imageOutputMap.set(resName, [outputImgBytes, imageFormat]);
      }
      checkbox.addEventListener('change', (event) => {
        const include = event.target.checked;
        if (include) {
          parent.postMessage({
            pluginMessage: {
              msg: 'include-image',
              imageHash: imageHash
            }
          }, '*');
          imageOutputMap.set(resName, [outputImgBytes, imageFormat]);
        } else {
          parent.postMessage({
            pluginMessage: {
              msg: 'exclude-image',
              imageHash: imageHash
            }
          }, '*');
          imageOutputMap.delete(resName);
        }
      });

      for (const nodeId of imageNodesMap.get(imageHash)) {
        const nodeIdElement = document.createElement('div');
        nodeIdElement.style.marginTop = '8px';
        nodeIdElement.textContent = "Node id: ";
        nodeIdElement.appendChild(createNodeIdSpan(nodeId));
        imageInfo.appendChild(nodeIdElement);
      }

      const divider = document.createElement('hr');
      imageInfo.appendChild(divider);
    }

    const downloadButton = document.getElementById('downloadImageButton');

    downloadButton.addEventListener('click', ()=>{
      const jszip = new JSZip();
      for (const [resName, [outputImgBytes, imageFormat]] of imageOutputMap) {
        jszip.file(`${resName}.${imageFormat}`, outputImgBytes, {base64: true});
      }
      jszip.generateAsync({ type: 'blob' })
        .then((content) => {
          const blobURL = window.URL.createObjectURL(content);
          const link = document.createElement('a');
          link.className = 'button button--primary';
          link.href = blobURL;
          link.download = "drawable.zip"
          link.click()
          link.setAttribute('download', name + '.zip');

          parent.postMessage({
            pluginMessage: {
              msg: 'close-plugin'
            }
          }, '*');
        });
    });
  }

  jsonInputFile.addEventListener('change', jsonInputFileChanged, false);
  stringsXmlInputFile.addEventListener('change', stringsXmlInputFileChanged, false);

  // Update the form from a selection change.
  window.onmessage = async function (event) {
    let msg = event.data.pluginMessage;

    if (msg.msg == 'selection-cleared') {
      currentSelection = null;
    }
    else if (msg.msg == 'selection') {
      currentSelection = {
        nodeType: msg.nodeType,
        extendedLayout: msg.extendedLayout,
      };
    }

    if (msg.msg == 'clippy') {
      openPage('errors');

      // Show suggestion to upload keywords doc if null
      let errorsMissingKeywords = document.getElementById('errorsMissingKeywords');
      errorsMissingKeywords.style.display = msg.clippyFile ? 'none' : 'block';

      // Clear out old errors
      while (errorList.firstChild) {
        errorList.removeChild(errorList.firstChild);
      }

      let errorsHigh = [];
      let errorsLow = [];

      if (msg.errors != null) {
        for (const e of msg.errors) {
          switch (e.severity) {
            case 1: errorsLow.push(e); break;
            case 2: errorsHigh.push(e); break;
          }
        }
      }

      function showHeader(title, show) {
        if (!show)
          return;
        let box = document.createElement('div');
        box.style.margin = '8px';
        box.style.borderBottom = '2px solid #000000';
        let t = document.createElement('span');
        t.textContent = title
        t.style.fontWeight = "bold";
        box.appendChild(t);
        errorList.appendChild(box);
      }

      function showErrors(errors) {
        for (const e of errors) {
          // Create a bunch of "error display" boxes.
          let box = document.createElement('div');
          box.style.margin = '8px';
          box.style.borderBottom = '1px solid #e0e0e0';
          // We could add an icon for the kind of error that this is...
          // ...or highlight based on severity.
          for (const run of e.runs) {
            let r = document.createElement('span');
            if ("string" == typeof run) {
              r.textContent = run + " ";
            } else {
              r.textContent = run.text + " ";
              r.style.color = '#00f';
              r.style.textDecoration = 'underline';
              r.onclick = () => {
                parent.postMessage({
                  pluginMessage: {
                    msg: 'show-node',
                    key: 'vsw-show-node',
                    node: run.node
                  }
                }, '*');
              };
            }
            box.appendChild(r);
          }
          errorList.appendChild(box);
        }
      }

      showHeader("Errors", errorsHigh.length > 0);
      showErrors(errorsHigh);
      showHeader("Warnings", errorsLow.length > 0);
      showErrors(errorsLow);
    }

    if (msg.msg == "check-keywords") {
      openPage('keywords');

      let keywordsFilename = document.getElementById('keywordsFilename');
      let keywordsName = document.getElementById('keywordsName');
      let keywordsVersion = document.getElementById('keywordsVersion');

      keywordsFilename.textContent = msg.file ? msg.file : ""
      keywordsName.textContent = msg.name ? msg.name : ""
      keywordsVersion.textContent = msg.version ? msg.version : ""
    }
    else if (msg.msg == "meters") {
      openPage('meters');
    }
    if (msg.msg == 'meters-selection-cleared') {
      currentSelection = null;
      currentNodeType = null;
      parentNodeType = null;
      parentSize = null;

      arcControls.style.display = 'none';
      arcSwitch.checked = false;
      arcSwitch.disabled = true;

      rotationControls.style.display = 'none';
      rotationSwitch.checked = false;
      rotationSwitch.disabled = true;

      barControls.style.display = 'none';
      barSwitch.checked = false;
      barSwitch.disabled = true;

      markerControls.style.display = 'none';
      markerSwitch.checked = false;
      markerSwitch.disabled = true;
    }
    else if (msg.msg == 'meters-selection') {
      setMeterData(msg);
    }

    if (msg.msg == 'localization') {
      openPage('localizationOptions')
    } else if (msg.msg == 'localization-output') {
      loadOutputStringData(msg.output);
      createOutputStringTable('outputStrings');
    } else if (msg.msg == 'localization-exclude-node-callback') {
      // Refresh the table, which recreate the whole table...
      createOutputStringTable('outputStrings');
    } else if (msg.msg == 'localization-ungroup-node-callback') {
      loadOutputStringData(msg.output);
      createOutputStringTable('outputStrings');
    } else if (msg.msg == 'image-export') {
      openPage('imageExport');
      createImageOutput(msg.imageNodesArray, msg.imageResNameArray, msg.imageBytesArray, msg.exportedImageHashArray);
    }

  }
</script>
